//! WASM bindings for `nesium-core`.
//!
//! This crate exposes a small, JS-friendly API for running the emulator in a
//! Web Worker and reading back a stable RGBA8888 framebuffer.
//!
//! Internally, rewind history stores the framebuffer as palette indices
//! (one byte per pixel) to keep memory usage low.

use wasm_bindgen::prelude::*;

use nesium_core::{
    Nes,
    cartridge::load_cartridge,
    config::region::Region,
    ppu::buffer::{ColorFormat, NearestPostProcessor, VideoPostProcessor},
    ppu::palette::{Palette, PaletteKind},
    reset_kind::ResetKind,
    state::{SnapshotMeta, nes::NesSnapshot},
};
use nesium_support::rewind::RewindState;
use nesium_support::video::filters::{
    LcdGridPostProcessor, SaiPostProcessor, SaiVariant, ScanlinePostProcessor, XbrzPostProcessor,
};
use sha1::{Digest, Sha1};

/// NES output resolution (visible area).
const WIDTH: usize = 256;
const HEIGHT: usize = 240;

/// Bytes per pixel for the exported framebuffer.
const BYTES_PER_PIXEL: usize = 4;

/// Framebuffer index plane length in bytes (one byte per pixel).
const INDEX_FRAME_LEN: usize = WIDTH * HEIGHT;

/// Install a panic hook so Rust panics show up in the browser console.
/// Call this once from JS/Worker during initialization.
#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}

fn js_err<E: ToString>(e: E) -> JsValue {
    JsValue::from_str(&e.to_string())
}

/// A thin WASM wrapper around `nesium-core`'s `Nes`.
///
/// Design goals:
/// - Keep `nesium-core` unchanged.
/// - Run the emulator inside a Worker (JS side).
/// - Expose a stable RGBA buffer pointer for JS to read from WASM memory.

#[wasm_bindgen]
pub struct WasmNes {
    nes: Nes,

    /// Stable RGBA8888 framebuffer owned by Rust/WASM.
    ///
    /// We copy bytes from the core's render buffer into this boxed slice so the
    /// pointer stays stable for JS (no reallocation / no lifetime concerns).
    ///
    /// Note: if WASM memory grows, JS must recreate its `Uint8Array` view using
    /// the latest `memory.buffer`.
    rgba: Vec<u8>,

    /// Current output framebuffer dimensions after applying the selected video filter.
    output_width: usize,
    output_height: usize,

    /// Interleaved audio samples (L, R, L, R, ...) generated by the last `run_frame(true)`.
    ///
    /// The buffer capacity is reused to avoid allocations on every frame.
    ///
    /// Note: if WASM memory grows, JS must recreate its `Float32Array` view using
    /// the latest `memory.buffer`.
    audio: Vec<f32>,

    /// Currently loaded ROM hash (SHA-1).
    rom_hash: Option<[u8; 32]>,

    /// Rewind state buffer.
    ///
    /// This is shared with desktop runtimes so the rewind behavior and memory
    /// model stay consistent across platforms.
    rewind: RewindState,

    /// Whether rewind is active.
    rewind_enabled: bool,

    /// Max number of frames to keep for rewind.
    rewind_capacity: usize,

    /// Whether the emulator is currently in rewind mode.
    rewinding: bool,

    /// Rewind speed percent.
    rewind_speed_percent: u16,

    /// TAS movie playback.
    movie: Option<nesium_support::tas::Movie>,
    movie_frame: usize,
}

#[wasm_bindgen]
#[derive(Debug, Clone, Copy)]
pub struct VideoOutputInfo {
    output_width: u32,
    output_height: u32,
}

#[wasm_bindgen]
impl VideoOutputInfo {
    #[wasm_bindgen(getter)]
    pub fn output_width(&self) -> u32 {
        self.output_width
    }

    #[wasm_bindgen(getter)]
    pub fn output_height(&self) -> u32 {
        self.output_height
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum WasmVideoFilter {
    None,
    Prescale2x,
    Prescale3x,
    Prescale4x,
    Sai2x,
    Super2xSai,
    SuperEagle,
    LcdGrid,
    Scanlines,
    Xbrz2x,
    Xbrz3x,
    Xbrz4x,
    Xbrz5x,
    Xbrz6x,
}

impl WasmVideoFilter {
    fn try_from_index(index: u32) -> Option<Self> {
        // Matches the Flutter `VideoFilter` enum ordering:
        // - apps/nesium_flutter/lib/bridge/api/video.dart
        match index {
            0 => Some(Self::None),
            1 => Some(Self::Prescale2x),
            2 => Some(Self::Prescale3x),
            3 => Some(Self::Prescale4x),
            // 4..6: HQX filters (not supported in WASM yet)
            7 => Some(Self::Sai2x),
            8 => Some(Self::Super2xSai),
            9 => Some(Self::SuperEagle),
            // 10..13: NTSC filters (not supported in WASM/Rust-only yet)
            14 => Some(Self::LcdGrid),
            15 => Some(Self::Scanlines),
            16 => Some(Self::Xbrz2x),
            17 => Some(Self::Xbrz3x),
            18 => Some(Self::Xbrz4x),
            19 => Some(Self::Xbrz5x),
            20 => Some(Self::Xbrz6x),
            _ => None,
        }
    }

    fn output_size(self) -> (usize, usize) {
        match self {
            Self::None => (WIDTH, HEIGHT),
            Self::Prescale2x
            | Self::Sai2x
            | Self::Super2xSai
            | Self::SuperEagle
            | Self::LcdGrid
            | Self::Xbrz2x => (WIDTH * 2, HEIGHT * 2),
            Self::Prescale3x | Self::Scanlines | Self::Xbrz3x => (WIDTH * 3, HEIGHT * 3),
            Self::Prescale4x | Self::Xbrz4x => (WIDTH * 4, HEIGHT * 4),
            Self::Xbrz5x => (WIDTH * 5, HEIGHT * 5),
            Self::Xbrz6x => (WIDTH * 6, HEIGHT * 6),
        }
    }

    fn post_processor(self) -> Box<dyn VideoPostProcessor> {
        match self {
            Self::None | Self::Prescale2x | Self::Prescale3x | Self::Prescale4x => {
                Box::new(NearestPostProcessor::default())
            }
            Self::Sai2x => Box::new(SaiPostProcessor::new(SaiVariant::Sai2x)),
            Self::Super2xSai => Box::new(SaiPostProcessor::new(SaiVariant::Super2xSai)),
            Self::SuperEagle => Box::new(SaiPostProcessor::new(SaiVariant::SuperEagle)),
            Self::LcdGrid => Box::new(LcdGridPostProcessor::new(1.0)),
            Self::Scanlines => Box::new(ScanlinePostProcessor::new(3, 0.25)), // 3x scale, 25% intensity
            Self::Xbrz2x => Box::new(XbrzPostProcessor::new(2)),
            Self::Xbrz3x => Box::new(XbrzPostProcessor::new(3)),
            Self::Xbrz4x => Box::new(XbrzPostProcessor::new(4)),
            Self::Xbrz5x => Box::new(XbrzPostProcessor::new(5)),
            Self::Xbrz6x => Box::new(XbrzPostProcessor::new(6)),
        }
    }
}

#[wasm_bindgen]
impl WasmNes {
    /// Create a new emulator instance.
    ///
    /// The core is configured to render into RGBA8888 so the exported frame can
    /// be consumed directly by Canvas/WebGL without extra palette mapping.
    ///
    /// `sample_rate_hz` should match the WebAudio output sample rate
    /// (`AudioContext.sampleRate`). If omitted, a reasonable default (48kHz) is used.
    #[wasm_bindgen(constructor)]
    pub fn new(sample_rate_hz: Option<u32>) -> WasmNes {
        // WebAudio decides the real output sample rate (AudioContext.sampleRate).
        // Pass that value from JS/Worker when constructing `WasmNes`.
        //
        // Using `Option` keeps backwards compatibility with `new()` (no args).
        let sample_rate_hz = sample_rate_hz.unwrap_or(48_000);

        let nes = Nes::builder()
            .format(ColorFormat::Rgba8888)
            .region(Region::Auto)
            .sample_rate(sample_rate_hz)
            .build();

        let output_width = WIDTH;
        let output_height = HEIGHT;

        WasmNes {
            nes,
            rgba: vec![0u8; output_width * output_height * BYTES_PER_PIXEL],
            output_width,
            output_height,
            audio: Vec::with_capacity(2048),
            rom_hash: None,
            rewind: RewindState::new(),
            rewind_enabled: false,
            rewind_capacity: 600,
            rewinding: false,
            rewind_speed_percent: 100,
            movie: None,
            movie_frame: 0,
        }
    }

    /// Load a TAS movie from an FM2 string.
    pub fn load_tas_movie(&mut self, data: &str) -> Result<(), JsValue> {
        let movie = nesium_support::tas::fm2::parse_str(data).map_err(js_err)?;

        // FCEUX logic: fully reload the game/power cycle before playing any movie.
        self.nes.reset(ResetKind::PowerOn);

        if let Some(savestate) = &movie.savestate {
            // If the movie starts from a savestate, apply it now.
            self.load_state(savestate)?;
        }

        self.movie = Some(movie);
        self.movie_frame = 0;
        Ok(())
    }

    /// Output width.
    pub fn width(&self) -> u32 {
        self.output_width as u32
    }

    /// Output height.
    pub fn height(&self) -> u32 {
        self.output_height as u32
    }

    /// Sets the video filter (Web/WASM currently supports PrescaleNx + SaI only).
    ///
    /// `filter_index` matches the Flutter `VideoFilter` enum index.
    pub fn set_video_filter(&mut self, filter_index: u32) -> Result<VideoOutputInfo, JsValue> {
        let filter = WasmVideoFilter::try_from_index(filter_index).ok_or_else(|| {
            JsValue::from_str("Unsupported video filter on web (WASM supports PrescaleNx + SaI)")
        })?;
        let (output_width, output_height) = filter.output_size();

        let palette = *self.nes.ppu.palette().as_colors();
        let fb = self.nes.ppu.framebuffer_mut();
        fb.set_output_config(output_width, output_height);
        fb.set_post_processor(filter.post_processor());
        fb.rebuild_packed(&palette);

        self.output_width = output_width;
        self.output_height = output_height;

        self.copy_rgba_from_core()?;

        Ok(VideoOutputInfo {
            output_width: output_width as u32,
            output_height: output_height as u32,
        })
    }

    /// Load an iNES ROM image from bytes.
    ///
    /// On success, the cartridge is inserted into the emulator.
    pub fn load_rom(&mut self, rom: &[u8]) -> Result<(), JsValue> {
        let hash = self.get_rom_hash(rom);
        let mut full_hash = [0u8; 32];
        full_hash[..hash.len()].copy_from_slice(&hash);

        let cartridge = load_cartridge(rom).map_err(js_err)?;
        self.nes.insert_cartridge(cartridge);
        self.rom_hash = Some(full_hash);
        Ok(())
    }

    /// Reset the emulator as if the console was power-cycled.
    pub fn power_on_reset(&mut self) {
        self.nes.reset(ResetKind::PowerOn);
    }

    /// Soft reset (CPU reset vector) without full power-cycle state.
    pub fn soft_reset(&mut self) {
        self.nes.reset(ResetKind::Soft);
    }

    /// Run until the next PPU frame completes, then update the exported RGBA buffer.
    ///
    /// This mirrors a typical frontend flow: call once per display refresh.
    pub fn run_frame(&mut self, emit_audio: bool) -> Result<(), JsValue> {
        if self.rewinding {
            return self.rewind_one_frame();
        }

        // Apply movie inputs if active.
        if let Some(movie) = &self.movie {
            if let Some(frame) = movie.frames.get(self.movie_frame) {
                let flags = frame.commands;
                // Apply reset flags from movie frame.
                if flags.contains(nesium_support::tas::FrameFlags::POWER) {
                    self.nes.reset(ResetKind::PowerOn);
                } else if flags.contains(nesium_support::tas::FrameFlags::RESET) {
                    self.nes.reset(ResetKind::Soft);
                }

                // Apply port inputs.
                for (i, &mask) in frame.ports.iter().enumerate() {
                    if let Some(controller) = self.nes.controllers.get_mut(i) {
                        controller.set_state(mask);
                    }
                }
            }
        }

        let samples = self.nes.run_frame(emit_audio);
        self.copy_rgba_from_core()?;

        self.audio.clear();
        if emit_audio {
            self.audio.extend_from_slice(&samples);
        }

        // Advance movie frame.
        if let Some(movie) = &self.movie {
            self.movie_frame += 1;
            if self.movie_frame >= movie.frames.len() {
                self.movie = None;
            }
        }

        if self.rewind_enabled {
            let meta = SnapshotMeta {
                tick: self.nes.master_clock(),
                ..Default::default()
            };
            if let Ok(snap) = self.nes.save_snapshot(meta) {
                // Rewind stores the canonical index plane (one byte per pixel).
                let mut indices = vec![0u8; INDEX_FRAME_LEN];
                self.nes.copy_render_index_buffer(&mut indices);

                // Keep the same rewind buffering behavior as desktop.
                self.rewind.push_frame(&snap, indices, self.rewind_capacity);
            }
        }

        Ok(())
    }

    /// Update rewind configuration.
    pub fn set_rewind_config(&mut self, enabled: bool, capacity: u32) {
        self.rewind_enabled = enabled;
        self.rewind_capacity = capacity as usize;
        if !enabled {
            // Reset the buffer when rewind is turned off.
            self.rewind = RewindState::new();
        }
    }

    /// Pops the last state from the rewind buffer and restores it.
    pub fn step_rewind(&mut self) -> Result<(), JsValue> {
        self.rewind_one_frame()
    }

    /// Sets the rewinding state.
    pub fn set_rewinding(&mut self, rewinding: bool) {
        self.rewinding = rewinding;
    }

    /// Sets the rewind speed.
    pub fn set_rewind_speed(&mut self, speed_percent: u16) {
        self.rewind_speed_percent = speed_percent;
    }

    fn rewind_one_frame(&mut self) -> Result<(), JsValue> {
        self.audio.clear();

        if let Some((snapshot, indices)) = self.rewind.rewind_frame() {
            self.nes.load_snapshot(&snapshot).map_err(js_err)?;

            // Refresh the framebuffer with the saved palette indices.
            // This keeps rewind output consistent with the active video filter.
            if indices.len() == INDEX_FRAME_LEN {
                let palette = *self.nes.ppu.palette().as_colors();
                let fb = self.nes.ppu.framebuffer_mut();
                let back_indices = fb.write();
                back_indices.copy_from_slice(&indices);
                fb.present(&palette);
                self.copy_rgba_from_core()?;
            }
        }

        Ok(())
    }

    /// Set the controller state for a given port.
    ///
    /// `bits` is a packed bitmask of controller buttons:
    /// - bit0: A
    /// - bit1: B
    /// - bit2: Select
    /// - bit3: Start
    /// - bit4: Up
    /// - bit5: Down
    /// - bit6: Left
    /// - bit7: Right
    ///
    /// This is designed for Web frontends: the main thread can compute a single
    /// bitmask from keyboard/touch/gamepad input and send it to the Worker.
    pub fn set_pad(&mut self, port: u32, bits: u32) -> Result<(), JsValue> {
        let port = port as usize;
        let bits_u8 = (bits & 0xFF) as u8;

        if let Some(controller) = self.nes.controllers.get_mut(port) {
            controller.set_state(bits_u8);
        }

        Ok(())
    }

    /// Selects a built-in palette preset.
    ///
    /// Accepts either Dart enum names (e.g. `nesdevNtsc`) or preset slugs
    /// (e.g. `nesdev-ntsc`).
    pub fn set_palette_preset(&mut self, kind: &str) -> Result<(), JsValue> {
        let kind =
            parse_palette_kind(kind).ok_or_else(|| JsValue::from_str("Invalid palette preset"))?;
        self.nes.set_palette(kind.palette());
        Ok(())
    }

    /// Loads a `.pal` blob (192-byte RGB or 256-byte RGBA) and sets it as the active palette.
    pub fn set_palette_pal_data(&mut self, data: &[u8]) -> Result<(), JsValue> {
        let palette = Palette::from_pal_data(data).map_err(js_err)?;
        self.nes.set_palette(palette);
        Ok(())
    }

    /// Enables a simple integer-FPS audio stretch.
    pub fn set_audio_integer_fps_scale(&mut self, scale: f64) {
        self.nes.set_audio_integer_fps_scale(scale);
    }

    /// Disables integer-FPS audio stretching and restores the default resampler input rate.
    pub fn reset_audio_integer_fps_scale(&mut self) {
        self.nes.reset_audio_integer_fps_scale();
    }

    /// Captures a full snapshot of the emulator state as a Postcard-serialized blob.
    pub fn save_state(&mut self) -> Result<Vec<u8>, JsValue> {
        let cart = self
            .nes
            .get_cartridge()
            .ok_or_else(|| JsValue::from_str("No cartridge loaded"))?;

        let header = cart.header();
        let mapper = Some((header.mapper(), header.submapper()));

        let meta = SnapshotMeta {
            tick: self.nes.master_clock(),
            rom_hash: self.rom_hash,
            mapper,
            format_version: 1, // Matches SaveState::FORMAT_VERSION
        };
        let snap = self.nes.save_snapshot(meta).map_err(js_err)?;
        snap.to_postcard_bytes().map_err(js_err)
    }

    /// Restores the emulator state from a Postcard-serialized blob.
    pub fn load_state(&mut self, data: &[u8]) -> Result<(), JsValue> {
        let snap = NesSnapshot::from_postcard_bytes(data).map_err(js_err)?;

        let cartridge = self
            .nes
            .get_cartridge()
            .ok_or_else(|| JsValue::from_str("No cartridge loaded"))?;

        // Validate ROM Mapper
        if let Some((mapper, submapper)) = snap.meta.mapper {
            if mapper != cartridge.header().mapper() || submapper != cartridge.header().submapper()
            {
                return Err(JsValue::from_str(
                    "ROM mapper mismatch: this save belongs to a different game",
                ));
            }
        }

        // Validate ROM Hash
        if let Some(expected_hash) = snap.meta.rom_hash {
            if Some(expected_hash) != self.rom_hash {
                return Err(JsValue::from_str(
                    "ROM hash mismatch: this save belongs to a different game",
                ));
            }
        }

        self.nes.load_snapshot(&snap).map_err(js_err)
    }

    /// Computes the SHA-1 hash of the currently loaded ROM.
    pub fn get_rom_hash(&self, rom_bytes: &[u8]) -> Vec<u8> {
        let mut hasher = Sha1::new();
        hasher.update(rom_bytes);
        hasher.finalize().to_vec()
    }

    /// Pointer to the stable RGBA buffer.
    ///
    /// JS usage:
    ///   const ptr = nes.frame_ptr();
    ///   const len = nes.frame_len();
    ///   const bytes = new Uint8Array(wasm_memory.buffer, ptr, len);
    ///
    /// The returned pointer remains valid until this `WasmNes` instance is dropped.
    pub fn frame_ptr(&self) -> *const u8 {
        self.rgba.as_ptr()
    }

    /// Length of the RGBA buffer in bytes (WIDTH*HEIGHT*4).
    pub fn frame_len(&self) -> usize {
        self.rgba.len()
    }

    /// Pointer to the interleaved audio sample buffer.
    ///
    /// JS usage:
    ///   const ptr = nes.audio_ptr();
    ///   const len = nes.audio_len();
    ///   const samples = new Float32Array(wasm_memory.buffer, ptr, len);
    pub fn audio_ptr(&self) -> *const f32 {
        self.audio.as_ptr()
    }

    /// Number of `f32` samples available in the audio buffer.
    ///
    /// For stereo interleaved data, `len` is 2x the number of frames.
    pub fn audio_len(&self) -> usize {
        self.audio.len()
    }
}

fn parse_palette_kind(kind: &str) -> Option<PaletteKind> {
    match kind {
        "nesdevNtsc" | "NesdevNtsc" | "nesdev-ntsc" => Some(PaletteKind::NesdevNtsc),
        "fbxCompositeDirect" | "FbxCompositeDirect" | "fbx-composite-direct" => {
            Some(PaletteKind::FbxCompositeDirect)
        }
        "sonyCxa2025AsUs" | "SonyCxa2025AsUs" | "sony-cxa2025as-us" => {
            Some(PaletteKind::SonyCxa2025AsUs)
        }
        "pal2C07" | "pal2c07" | "Pal2c07" | "pal-2c07" => Some(PaletteKind::Pal2c07),
        "rawLinear" | "RawLinear" | "raw-linear" => Some(PaletteKind::RawLinear),
        _ => None,
    }
}

impl WasmNes {
    /// Copies RGBA8888 bytes from the core render buffer into the exported framebuffer.
    ///
    /// The core is configured to render RGBA8888 for WASM so the exported frame
    /// can be consumed directly by the frontend.
    fn copy_rgba_from_core(&mut self) -> Result<(), JsValue> {
        let src = self.nes.render_buffer();

        if self.rgba.len() != src.len() {
            self.rgba.resize(src.len(), 0);
        }
        self.rgba.copy_from_slice(src);
        Ok(())
    }
}
