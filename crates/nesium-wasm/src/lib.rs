//! WASM bindings for `nesium-core`.
//!
//! This crate exposes a small, JS-friendly API for running the emulator in a
//! Web Worker and reading back a stable RGBA8888 framebuffer.

use std::collections::VecDeque;
use wasm_bindgen::prelude::*;

use nesium_core::{
    Nes,
    cartridge::load_cartridge,
    config::region::Region,
    ppu::buffer::ColorFormat,
    ppu::palette::{Palette, PaletteKind},
    reset_kind::ResetKind,
    state::{SnapshotMeta, nes::NesSnapshot},
};
use sha1::{Digest, Sha1};

/// NES output resolution (visible area).
const WIDTH: usize = 256;
const HEIGHT: usize = 240;

/// Bytes per pixel for the exported framebuffer.
const BYTES_PER_PIXEL: usize = 4;

/// RGBA8888 framebuffer size in bytes.
const RGBA_FRAME_LEN: usize = WIDTH * HEIGHT * BYTES_PER_PIXEL;

/// Install a panic hook so Rust panics show up in the browser console.
/// Call this once from JS/Worker during initialization.
#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}

fn js_err<E: ToString>(e: E) -> JsValue {
    JsValue::from_str(&e.to_string())
}

/// A thin WASM wrapper around `nesium-core`'s `Nes`.
///
/// Design goals:
/// - Keep `nesium-core` unchanged.
/// - Run the emulator inside a Worker (JS side).
/// - Expose a stable RGBA buffer pointer for JS to read from WASM memory.
struct RewindEntry {
    snapshot: NesSnapshot,
    pixels: Vec<u8>,
}

#[wasm_bindgen]
pub struct WasmNes {
    nes: Nes,

    /// Stable RGBA8888 framebuffer owned by Rust/WASM.
    ///
    /// We copy bytes from the core's render buffer into this boxed slice so the
    /// pointer stays stable for JS (no reallocation / no lifetime concerns).
    ///
    /// Note: if WASM memory grows, JS must recreate its `Uint8Array` view using
    /// the latest `memory.buffer`.
    rgba: Box<[u8]>,

    /// Interleaved audio samples (L, R, L, R, ...) generated by the last `run_frame(true)`.
    ///
    /// The buffer capacity is reused to avoid allocations on every frame.
    ///
    /// Note: if WASM memory grows, JS must recreate its `Float32Array` view using
    /// the latest `memory.buffer`.
    audio: Vec<f32>,

    /// Currently loaded ROM hash (SHA-1).
    rom_hash: Option<[u8; 32]>,

    /// Memory buffer for rewind states.
    rewind_buffer: VecDeque<RewindEntry>,

    /// Whether rewind is active.
    rewind_enabled: bool,

    /// Max number of frames to keep for rewind.
    rewind_capacity: usize,

    /// Whether the emulator is currently in rewind mode.
    rewinding: bool,
}

#[wasm_bindgen]
impl WasmNes {
    /// Create a new emulator instance.
    ///
    /// The core is configured to render into RGBA8888 so the exported frame can
    /// be consumed directly by Canvas/WebGL without extra palette mapping.
    ///
    /// `sample_rate_hz` should match the WebAudio output sample rate
    /// (`AudioContext.sampleRate`). If omitted, a reasonable default (48kHz) is used.
    #[wasm_bindgen(constructor)]
    pub fn new(sample_rate_hz: Option<u32>) -> WasmNes {
        // WebAudio decides the real output sample rate (AudioContext.sampleRate).
        // Pass that value from JS/Worker when constructing `WasmNes`.
        //
        // Using `Option` keeps backwards compatibility with `new()` (no args).
        let sample_rate_hz = sample_rate_hz.unwrap_or(48_000);

        let nes = Nes::builder()
            .format(ColorFormat::Rgba8888)
            .region(Region::Auto)
            .sample_rate(sample_rate_hz)
            .build();

        WasmNes {
            nes,
            rgba: vec![0u8; RGBA_FRAME_LEN].into_boxed_slice(),
            audio: Vec::with_capacity(2048),
            rom_hash: None,
            rewind_buffer: VecDeque::new(),
            rewind_enabled: false,
            rewind_capacity: 600,
            rewinding: false,
        }
    }

    /// Output width.
    pub fn width(&self) -> u32 {
        WIDTH as u32
    }

    /// Output height.
    pub fn height(&self) -> u32 {
        HEIGHT as u32
    }

    /// Load an iNES ROM image from bytes.
    ///
    /// On success, the cartridge is inserted into the emulator.
    pub fn load_rom(&mut self, rom: &[u8]) -> Result<(), JsValue> {
        let hash = self.get_rom_hash(rom);
        let mut full_hash = [0u8; 32];
        full_hash[..hash.len()].copy_from_slice(&hash);

        let cartridge = load_cartridge(rom).map_err(js_err)?;
        self.nes.insert_cartridge(cartridge);
        self.rom_hash = Some(full_hash);
        Ok(())
    }

    /// Reset the emulator as if the console was power-cycled.
    pub fn power_on_reset(&mut self) {
        self.nes.reset(ResetKind::PowerOn);
    }

    /// Soft reset (CPU reset vector) without full power-cycle state.
    pub fn soft_reset(&mut self) {
        self.nes.reset(ResetKind::Soft);
    }

    /// Run until the next PPU frame completes, then update the exported RGBA buffer.
    ///
    /// This mirrors a typical frontend flow: call once per display refresh.
    pub fn run_frame(&mut self, emit_audio: bool) -> Result<(), JsValue> {
        if self.rewinding {
            return self.rewind_one_frame();
        }

        let samples = self.nes.run_frame(emit_audio);
        self.copy_rgba_from_core()?;

        self.audio.clear();
        if emit_audio {
            self.audio.extend_from_slice(&samples);
        }

        if self.rewind_enabled {
            let meta = SnapshotMeta {
                tick: self.nes.master_clock(),
                ..Default::default()
            };
            if let Ok(snap) = self.nes.save_snapshot(meta) {
                let mut pixels = vec![0u8; RGBA_FRAME_LEN];
                self.nes.copy_render_buffer(&mut pixels);
                self.rewind_buffer.push_back(RewindEntry {
                    snapshot: snap,
                    pixels,
                });
                while self.rewind_buffer.len() > self.rewind_capacity {
                    self.rewind_buffer.pop_front();
                }
            }
        }

        Ok(())
    }

    /// Update rewind configuration.
    pub fn set_rewind_config(&mut self, enabled: bool, capacity: u32) {
        self.rewind_enabled = enabled;
        self.rewind_capacity = capacity as usize;
        if !enabled {
            self.rewind_buffer.clear();
        }
    }

    /// Pops the last state from the rewind buffer and restores it.
    pub fn step_rewind(&mut self) -> Result<(), JsValue> {
        self.rewind_one_frame()
    }

    /// Sets the rewinding state.
    pub fn set_rewinding(&mut self, rewinding: bool) {
        self.rewinding = rewinding;
    }

    fn rewind_one_frame(&mut self) -> Result<(), JsValue> {
        self.audio.clear();
        if let Some(entry) = self.rewind_buffer.pop_back() {
            self.nes.load_snapshot(&entry.snapshot).map_err(js_err)?;

            // For WASM, we manually refresh the RGBA buffer from the saved pixel data
            if entry.pixels.len() == RGBA_FRAME_LEN {
                self.rgba.copy_from_slice(&entry.pixels);
            }
        }
        Ok(())
    }

    /// Set the controller state for a given port.
    ///
    /// `bits` is a packed bitmask of controller buttons:
    /// - bit0: A
    /// - bit1: B
    /// - bit2: Select
    /// - bit3: Start
    /// - bit4: Up
    /// - bit5: Down
    /// - bit6: Left
    /// - bit7: Right
    ///
    /// This is designed for Web frontends: the main thread can compute a single
    /// bitmask from keyboard/touch/gamepad input and send it to the Worker.
    pub fn set_pad(&mut self, port: u32, bits: u32) -> Result<(), JsValue> {
        let port = port as usize;
        let bits_u8 = (bits & 0xFF) as u8;

        let controller = self
            .nes
            .controllers
            .get_mut(port)
            .ok_or_else(|| JsValue::from_str("Invalid controller port"))?;

        controller.set_state(bits_u8);
        Ok(())
    }

    /// Selects a built-in palette preset.
    ///
    /// Accepts either Dart enum names (e.g. `nesdevNtsc`) or preset slugs
    /// (e.g. `nesdev-ntsc`).
    pub fn set_palette_preset(&mut self, kind: &str) -> Result<(), JsValue> {
        let kind =
            parse_palette_kind(kind).ok_or_else(|| JsValue::from_str("Invalid palette preset"))?;
        self.nes.set_palette(kind.palette());
        Ok(())
    }

    /// Loads a `.pal` blob (192-byte RGB or 256-byte RGBA) and sets it as the active palette.
    pub fn set_palette_pal_data(&mut self, data: &[u8]) -> Result<(), JsValue> {
        let palette = Palette::from_pal_data(data).map_err(js_err)?;
        self.nes.set_palette(palette);
        Ok(())
    }

    /// Enables a simple integer-FPS audio stretch.
    pub fn set_audio_integer_fps_scale(&mut self, scale: f64) {
        self.nes.set_audio_integer_fps_scale(scale);
    }

    /// Disables integer-FPS audio stretching and restores the default resampler input rate.
    pub fn reset_audio_integer_fps_scale(&mut self) {
        self.nes.reset_audio_integer_fps_scale();
    }

    /// Captures a full snapshot of the emulator state as a Postcard-serialized blob.
    pub fn save_state(&mut self) -> Result<Vec<u8>, JsValue> {
        let cart = self
            .nes
            .get_cartridge()
            .ok_or_else(|| JsValue::from_str("No cartridge loaded"))?;

        let header = cart.header();
        let mapper = Some((header.mapper(), header.submapper()));

        let meta = SnapshotMeta {
            tick: self.nes.master_clock(),
            rom_hash: self.rom_hash,
            mapper,
            format_version: 1, // Matches SaveState::FORMAT_VERSION
        };
        let snap = self.nes.save_snapshot(meta).map_err(js_err)?;
        snap.to_postcard_bytes().map_err(js_err)
    }

    /// Restores the emulator state from a Postcard-serialized blob.
    pub fn load_state(&mut self, data: &[u8]) -> Result<(), JsValue> {
        let snap = NesSnapshot::from_postcard_bytes(data).map_err(js_err)?;

        let cartridge = self
            .nes
            .get_cartridge()
            .ok_or_else(|| JsValue::from_str("No cartridge loaded"))?;

        // Validate ROM Mapper
        if let Some((mapper, submapper)) = snap.meta.mapper {
            if mapper != cartridge.header().mapper() || submapper != cartridge.header().submapper()
            {
                return Err(JsValue::from_str(
                    "ROM mapper mismatch: this save belongs to a different game",
                ));
            }
        }

        // Validate ROM Hash
        if let Some(expected_hash) = snap.meta.rom_hash {
            if Some(expected_hash) != self.rom_hash {
                return Err(JsValue::from_str(
                    "ROM hash mismatch: this save belongs to a different game",
                ));
            }
        }

        self.nes.load_snapshot(&snap).map_err(js_err)
    }

    /// Computes the SHA-1 hash of the currently loaded ROM.
    pub fn get_rom_hash(&self, rom_bytes: &[u8]) -> Vec<u8> {
        let mut hasher = Sha1::new();
        hasher.update(rom_bytes);
        hasher.finalize().to_vec()
    }

    /// Pointer to the stable RGBA buffer.
    ///
    /// JS usage:
    ///   const ptr = nes.frame_ptr();
    ///   const len = nes.frame_len();
    ///   const bytes = new Uint8Array(wasm_memory.buffer, ptr, len);
    ///
    /// The returned pointer remains valid until this `WasmNes` instance is dropped.
    pub fn frame_ptr(&self) -> *const u8 {
        self.rgba.as_ptr()
    }

    /// Length of the RGBA buffer in bytes (WIDTH*HEIGHT*4).
    pub fn frame_len(&self) -> usize {
        self.rgba.len()
    }

    /// Pointer to the interleaved audio sample buffer.
    ///
    /// JS usage:
    ///   const ptr = nes.audio_ptr();
    ///   const len = nes.audio_len();
    ///   const samples = new Float32Array(wasm_memory.buffer, ptr, len);
    pub fn audio_ptr(&self) -> *const f32 {
        self.audio.as_ptr()
    }

    /// Number of `f32` samples available in the audio buffer.
    ///
    /// For stereo interleaved data, `len` is 2x the number of frames.
    pub fn audio_len(&self) -> usize {
        self.audio.len()
    }
}

fn parse_palette_kind(kind: &str) -> Option<PaletteKind> {
    match kind {
        "nesdevNtsc" | "NesdevNtsc" | "nesdev-ntsc" => Some(PaletteKind::NesdevNtsc),
        "fbxCompositeDirect" | "FbxCompositeDirect" | "fbx-composite-direct" => {
            Some(PaletteKind::FbxCompositeDirect)
        }
        "sonyCxa2025AsUs" | "SonyCxa2025AsUs" | "sony-cxa2025as-us" => {
            Some(PaletteKind::SonyCxa2025AsUs)
        }
        "pal2C07" | "pal2c07" | "Pal2c07" | "pal-2c07" => Some(PaletteKind::Pal2c07),
        "rawLinear" | "RawLinear" | "raw-linear" => Some(PaletteKind::RawLinear),
        _ => None,
    }
}

impl WasmNes {
    /// Copy RGBA8888 bytes from the core render buffer into the exported framebuffer.
    ///
    /// Assumes `Nes::render_buffer()` returns RGBA8888 in row-major order.
    fn copy_rgba_from_core(&mut self) -> Result<(), JsValue> {
        let src = self.nes.render_buffer();

        if src.len() != RGBA_FRAME_LEN {
            return Err(JsValue::from_str(&format!(
                "Unexpected render buffer size: {} bytes (expected {} bytes)",
                src.len(),
                RGBA_FRAME_LEN
            )));
        }

        self.rgba.copy_from_slice(src);
        Ok(())
    }
}
