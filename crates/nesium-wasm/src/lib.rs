//! WASM bindings for `nesium-core`.
//!
//! This crate exposes a small, JS-friendly API for running the emulator in a
//! Web Worker and reading back a stable RGBA8888 framebuffer.

use wasm_bindgen::prelude::*;

use nesium_core::{
    Nes,
    cartridge::load_cartridge,
    config::region::Region,
    ppu::buffer::ColorFormat,
    ppu::palette::{Palette, PaletteKind},
    reset_kind::ResetKind,
};

/// NES output resolution (visible area).
const WIDTH: usize = 256;
const HEIGHT: usize = 240;

/// Bytes per pixel for the exported framebuffer.
const BYTES_PER_PIXEL: usize = 4;

/// RGBA8888 framebuffer size in bytes.
const RGBA_FRAME_LEN: usize = WIDTH * HEIGHT * BYTES_PER_PIXEL;

/// Install a panic hook so Rust panics show up in the browser console.
/// Call this once from JS/Worker during initialization.
#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}

fn js_err<E: ToString>(e: E) -> JsValue {
    JsValue::from_str(&e.to_string())
}

/// A thin WASM wrapper around `nesium-core`'s `Nes`.
///
/// Design goals:
/// - Keep `nesium-core` unchanged.
/// - Run the emulator inside a Worker (JS side).
/// - Expose a stable RGBA buffer pointer for JS to read from WASM memory.
#[wasm_bindgen]
pub struct WasmNes {
    nes: Nes,

    /// Stable RGBA8888 framebuffer owned by Rust/WASM.
    ///
    /// We copy bytes from the core's render buffer into this boxed slice so the
    /// pointer stays stable for JS (no reallocation / no lifetime concerns).
    ///
    /// Note: if WASM memory grows, JS must recreate its `Uint8Array` view using
    /// the latest `memory.buffer`.
    rgba: Box<[u8]>,

    /// Interleaved audio samples (L, R, L, R, ...) generated by the last `run_frame(true)`.
    ///
    /// The buffer capacity is reused to avoid allocations on every frame.
    ///
    /// Note: if WASM memory grows, JS must recreate its `Float32Array` view using
    /// the latest `memory.buffer`.
    audio: Vec<f32>,
}

#[wasm_bindgen]
impl WasmNes {
    /// Create a new emulator instance.
    ///
    /// The core is configured to render into RGBA8888 so the exported frame can
    /// be consumed directly by Canvas/WebGL without extra palette mapping.
    ///
    /// `sample_rate_hz` should match the WebAudio output sample rate
    /// (`AudioContext.sampleRate`). If omitted, a reasonable default (48kHz) is used.
    #[wasm_bindgen(constructor)]
    pub fn new(sample_rate_hz: Option<u32>) -> WasmNes {
        // WebAudio decides the real output sample rate (AudioContext.sampleRate).
        // Pass that value from JS/Worker when constructing `WasmNes`.
        //
        // Using `Option` keeps backwards compatibility with `new()` (no args).
        let sample_rate_hz = sample_rate_hz.unwrap_or(48_000);

        let nes = Nes::builder()
            .format(ColorFormat::Rgba8888)
            .region(Region::Auto)
            .sample_rate(sample_rate_hz)
            .build();

        WasmNes {
            nes,
            rgba: vec![0u8; RGBA_FRAME_LEN].into_boxed_slice(),
            audio: Vec::with_capacity(2048),
        }
    }

    /// Output width.
    pub fn width(&self) -> u32 {
        WIDTH as u32
    }

    /// Output height.
    pub fn height(&self) -> u32 {
        HEIGHT as u32
    }

    /// Load an iNES ROM image from bytes.
    ///
    /// On success, the cartridge is inserted into the emulator.
    pub fn load_rom(&mut self, rom: &[u8]) -> Result<(), JsValue> {
        let cartridge = load_cartridge(rom).map_err(js_err)?;
        self.nes.insert_cartridge(cartridge);
        Ok(())
    }

    /// Reset the emulator as if the console was power-cycled.
    pub fn power_on_reset(&mut self) {
        self.nes.reset(ResetKind::PowerOn);
    }

    /// Soft reset (CPU reset vector) without full power-cycle state.
    pub fn soft_reset(&mut self) {
        self.nes.reset(ResetKind::Soft);
    }

    /// Run until the next PPU frame completes, then update the exported RGBA buffer.
    ///
    /// This mirrors a typical frontend flow: call once per display refresh.
    pub fn run_frame(&mut self, emit_audio: bool) -> Result<(), JsValue> {
        let samples = self.nes.run_frame(emit_audio);
        self.copy_rgba_from_core()?;

        if emit_audio {
            self.audio.clear();
            self.audio.extend_from_slice(&samples);
        }

        Ok(())
    }

    /// Set the controller state for a given port.
    ///
    /// `bits` is a packed bitmask of controller buttons:
    /// - bit0: A
    /// - bit1: B
    /// - bit2: Select
    /// - bit3: Start
    /// - bit4: Up
    /// - bit5: Down
    /// - bit6: Left
    /// - bit7: Right
    ///
    /// This is designed for Web frontends: the main thread can compute a single
    /// bitmask from keyboard/touch/gamepad input and send it to the Worker.
    pub fn set_pad(&mut self, port: u32, bits: u32) -> Result<(), JsValue> {
        let port = port as usize;
        let bits_u8 = (bits & 0xFF) as u8;

        let controller = self
            .nes
            .controllers
            .get_mut(port)
            .ok_or_else(|| JsValue::from_str("Invalid controller port"))?;

        controller.set_state(bits_u8);
        Ok(())
    }

    /// Selects a built-in palette preset.
    ///
    /// Accepts either Dart enum names (e.g. `nesdevNtsc`) or preset slugs
    /// (e.g. `nesdev-ntsc`).
    pub fn set_palette_preset(&mut self, kind: &str) -> Result<(), JsValue> {
        let kind =
            parse_palette_kind(kind).ok_or_else(|| JsValue::from_str("Invalid palette preset"))?;
        self.nes.set_palette(kind.palette());
        Ok(())
    }

    /// Loads a `.pal` blob (192-byte RGB or 256-byte RGBA) and sets it as the active palette.
    pub fn set_palette_pal_data(&mut self, data: &[u8]) -> Result<(), JsValue> {
        let palette = Palette::from_pal_data(data).map_err(js_err)?;
        self.nes.set_palette(palette);
        Ok(())
    }

    /// Enables a simple integer-FPS audio stretch.
    pub fn set_audio_integer_fps_scale(&mut self, scale: f64) {
        self.nes.set_audio_integer_fps_scale(scale);
    }

    /// Disables integer-FPS audio stretching and restores the default resampler input rate.
    pub fn reset_audio_integer_fps_scale(&mut self) {
        self.nes.reset_audio_integer_fps_scale();
    }

    /// Pointer to the stable RGBA buffer.
    ///
    /// JS usage:
    ///   const ptr = nes.frame_ptr();
    ///   const len = nes.frame_len();
    ///   const bytes = new Uint8Array(wasm_memory.buffer, ptr, len);
    ///
    /// The returned pointer remains valid until this `WasmNes` instance is dropped.
    pub fn frame_ptr(&self) -> *const u8 {
        self.rgba.as_ptr()
    }

    /// Length of the RGBA buffer in bytes (WIDTH*HEIGHT*4).
    pub fn frame_len(&self) -> usize {
        self.rgba.len()
    }

    /// Pointer to the interleaved audio sample buffer.
    ///
    /// JS usage:
    ///   const ptr = nes.audio_ptr();
    ///   const len = nes.audio_len();
    ///   const samples = new Float32Array(wasm_memory.buffer, ptr, len);
    pub fn audio_ptr(&self) -> *const f32 {
        self.audio.as_ptr()
    }

    /// Number of `f32` samples available in the audio buffer.
    ///
    /// For stereo interleaved data, `len` is 2x the number of frames.
    pub fn audio_len(&self) -> usize {
        self.audio.len()
    }
}

fn parse_palette_kind(kind: &str) -> Option<PaletteKind> {
    match kind {
        "nesdevNtsc" | "NesdevNtsc" | "nesdev-ntsc" => Some(PaletteKind::NesdevNtsc),
        "fbxCompositeDirect" | "FbxCompositeDirect" | "fbx-composite-direct" => {
            Some(PaletteKind::FbxCompositeDirect)
        }
        "sonyCxa2025AsUs" | "SonyCxa2025AsUs" | "sony-cxa2025as-us" => {
            Some(PaletteKind::SonyCxa2025AsUs)
        }
        "pal2C07" | "pal2c07" | "Pal2c07" | "pal-2c07" => Some(PaletteKind::Pal2c07),
        "rawLinear" | "RawLinear" | "raw-linear" => Some(PaletteKind::RawLinear),
        _ => None,
    }
}

impl WasmNes {
    /// Copy RGBA8888 bytes from the core render buffer into the exported framebuffer.
    ///
    /// Assumes `Nes::render_buffer()` returns RGBA8888 in row-major order.
    fn copy_rgba_from_core(&mut self) -> Result<(), JsValue> {
        let src = self.nes.render_buffer();

        if src.len() != RGBA_FRAME_LEN {
            return Err(JsValue::from_str(&format!(
                "Unexpected render buffer size: {} bytes (expected {} bytes)",
                src.len(),
                RGBA_FRAME_LEN
            )));
        }

        self.rgba.copy_from_slice(src);
        Ok(())
    }
}
