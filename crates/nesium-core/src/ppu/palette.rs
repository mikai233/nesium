//! NES PPU master palette utilities.
//!
//! The hardware exposes 64 color slots that palette RAM indexes into. The
//! values below are a commonly used NTSC palette that matches the "canonical"
//! table published on NesDev. While the real hardware output depends on the
//! display and decode circuitry, this list serves as a sensible default that
//! higher level front-ends can convert into their preferred color space. Each
//! preset is stored once and referenced via [`Palette::Static`] to avoid
//! redundant copies.
//!
//! ## Understanding the layout
//! Palette indices are 6-bit values in the `$00-$3F` range. The upper two bits
//! (the high nibble) indicate the luminance level and the lower four bits select
//! the hue. This maps naturally onto a 4×16 table:
//!
//! ```text
//!             Hue (low nibble)
//!       0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
//!   -----------------------------------------------------------------
//! L0  $00 $01 $02 $03 $04 $05 $06 $07 $08 $09 $0A $0B $0C $0D $0E $0F
//! L1  $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $1A $1B $1C $1D $1E $1F
//! L2  $20 $21 $22 $23 $24 $25 $26 $27 $28 $29 $2A $2B $2C $2D $2E $2F
//! L3  $30 $31 $32 $33 $34 $35 $36 $37 $38 $39 $3A $3B $3C $3D $3E $3F
//! ```
//!
//! - Rows (L0..L3) share the same hue progression but increase in brightness.
//! - Columns (0x0..=0xF) step through the available hues, roughly moving along
//!   the NES color wheel.
//! - Several entries are intentionally black because the original hardware
//!   produced invalid or identical signals there. Keeping them black mirrors the
//!   reference palette and helps front-ends flag reserved values.
//!
//! To look up an RGB triple you can treat an index as `(index >> 4, index & 0x0F)`
//! and consult the appropriate row/column entry in the tables below. This file
//! follows the same arrangement to make the data easy to compare with
//! documentation and debugging tools.
//!
//! In addition to the canonical Nesdev palette the module also ships a handful
//! of alternative presets (`[`PaletteKind`]`) and helpers to import external
//! `.pal` files.

use std::{fs, path::Path};

use crate::error::Error;

/// Simple RGB triplet described with 8-bit channels.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}

impl Color {
    pub const fn new(r: u8, g: u8, b: u8) -> Self {
        Self { r, g, b }
    }

    pub const BLACK: Self = Self::new(0, 0, 0);
}

/// Helper macro to keep palette definitions compact.
macro_rules! rgb {
    ($r:expr, $g:expr, $b:expr) => {
        Color::new($r, $g, $b)
    };
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Palette {
    Static(&'static [Color; 64]),
    Dynamic([Color; 64]),
}

impl Default for Palette {
    fn default() -> Self {
        Palette::Static(&NESDEV_TABLE)
    }
}

impl Palette {
    /// Returns the RGB triple for the provided palette index (`$00-$3F`).
    pub fn color(&self, index: u8) -> Color {
        let idx = (index as usize) & 0x3F;
        match self {
            Palette::Static(colors) => colors[idx],
            Palette::Dynamic(colors) => colors[idx],
        }
    }

    /// Provides direct access to the underlying color array.
    pub fn as_colors(&self) -> &[Color; 64] {
        match self {
            Palette::Static(colors) => colors,
            Palette::Dynamic(colors) => colors,
        }
    }

    /// Builds a palette from a raw `.pal` blob. Accepts both 192-byte (RGB) and
    /// 256-byte (RGBA) layouts.
    pub fn from_pal_data(data: &[u8]) -> Result<Self, Error> {
        let stride = match data.len() {
            192 => 3,
            256 => 4,
            actual => return Err(Error::InvalidPaletteSize { actual }),
        };
        let mut colors = [Color::BLACK; 64];
        let mut idx = 0;
        while idx < 64 {
            let base = idx * stride;
            colors[idx] = Color::new(data[base], data[base + 1], data[base + 2]);
            idx += 1;
        }
        Ok(Palette::Dynamic(colors))
    }

    /// Loads a `.pal` file from disk and parses it using [`Palette::from_pal_data`].
    pub fn from_pal_file(path: impl AsRef<Path>) -> Result<Self, Error> {
        let data = fs::read(path)?;
        Self::from_pal_data(&data)
    }
}

/// Collection of built-in palettes that can be selected without loading a file.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PaletteKind {
    /// Canonical Nesdev/Ntsc palette. Matches the default data defined below.
    NesdevNtsc,
    /// FirebrandX's "Composite Direct" capture (CRT composite signal).
    FbxCompositeDirect,
    /// Sony CXA2025AS US RGB PPU measurements (PVM/RGB mod look).
    SonyCxa2025AsUs,
    /// FirebrandX "Royaltea" capture taken from an RP2C07 PAL PPU.
    Pal2c07,
    /// Straight YIQ-to-RGB conversion without decoder tweaks. Useful for theory/debugging.
    RawLinear,
}

impl Default for PaletteKind {
    fn default() -> Self {
        PaletteKind::NesdevNtsc
    }
}

impl PaletteKind {
    pub const fn as_str(self) -> &'static str {
        match self {
            PaletteKind::NesdevNtsc => "nesdev-ntsc",
            PaletteKind::FbxCompositeDirect => "fbx-composite-direct",
            PaletteKind::SonyCxa2025AsUs => "sony-cxa2025as-us",
            PaletteKind::Pal2c07 => "pal-2c07",
            PaletteKind::RawLinear => "raw-linear",
        }
    }

    pub const fn description(self) -> &'static str {
        match self {
            PaletteKind::NesdevNtsc => "Canonical palette reproduced from the Nesdev wiki",
            PaletteKind::FbxCompositeDirect => {
                "FirebrandX composite capture (looks like a calibrated CRT)"
            }
            PaletteKind::SonyCxa2025AsUs => "Sony CXA2025AS RGB/PVM style colors",
            PaletteKind::Pal2c07 => "RP2C07 PAL PPU capture (FirebrandX Royaltea palette)",
            PaletteKind::RawLinear => "Direct YIQ→RGB conversion without decoder adjustments",
        }
    }

    pub const fn all() -> &'static [PaletteKind] {
        &[
            PaletteKind::NesdevNtsc,
            PaletteKind::FbxCompositeDirect,
            PaletteKind::SonyCxa2025AsUs,
            PaletteKind::Pal2c07,
            PaletteKind::RawLinear,
        ]
    }

    pub const fn palette(self) -> Palette {
        match self {
            PaletteKind::NesdevNtsc => Palette::Static(&NESDEV_TABLE),
            PaletteKind::FbxCompositeDirect => Palette::Static(&FBX_COMPOSITE_DIRECT_DATA),
            PaletteKind::SonyCxa2025AsUs => Palette::Static(&SONY_CXA2025AS_US_DATA),
            PaletteKind::Pal2c07 => Palette::Static(&PAL_2C07_DATA),
            PaletteKind::RawLinear => Palette::Static(&RAW_LINEAR_DATA),
        }
    }
}

/// Default NTSC system palette organized as `Lx` / hue table entries.
#[rustfmt::skip]
const NESDEV_TABLE: [Color; 64] = [
    // L0 ($00-$0F)
    rgb!(0x7C, 0x7C, 0x7C), rgb!(0x00, 0x00, 0xFC), rgb!(0x00, 0x00, 0xBC), rgb!(0x44, 0x28, 0xBC),
    rgb!(0x94, 0x00, 0x84), rgb!(0xA8, 0x00, 0x20), rgb!(0xA8, 0x10, 0x00), rgb!(0x88, 0x14, 0x00),
    rgb!(0x50, 0x30, 0x00), rgb!(0x00, 0x78, 0x00), rgb!(0x00, 0x68, 0x00), rgb!(0x00, 0x58, 0x00),
    rgb!(0x00, 0x40, 0x58), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L1 ($10-$1F)
    rgb!(0xBC, 0xBC, 0xBC), rgb!(0x00, 0x78, 0xF8), rgb!(0x00, 0x58, 0xF8), rgb!(0x68, 0x44, 0xFC),
    rgb!(0xD8, 0x00, 0xCC), rgb!(0xE4, 0x00, 0x58), rgb!(0xF8, 0x38, 0x00), rgb!(0xE4, 0x5C, 0x10),
    rgb!(0xAC, 0x7C, 0x00), rgb!(0x00, 0xB8, 0x00), rgb!(0x00, 0xA8, 0x00), rgb!(0x00, 0xA8, 0x44),
    rgb!(0x00, 0x88, 0x88), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L2 ($20-$2F)
    rgb!(0xF8, 0xF8, 0xF8), rgb!(0x3C, 0xBC, 0xFC), rgb!(0x68, 0x88, 0xFC), rgb!(0x98, 0x78, 0xF8),
    rgb!(0xF8, 0x78, 0xF8), rgb!(0xF8, 0x58, 0x98), rgb!(0xF8, 0x78, 0x58), rgb!(0xF8, 0xA4, 0x38),
    rgb!(0xF8, 0xB8, 0x00), rgb!(0xB8, 0xF8, 0x18), rgb!(0x58, 0xD8, 0x54), rgb!(0x58, 0xF8, 0x98),
    rgb!(0x00, 0xE8, 0xD8), rgb!(0x78, 0x78, 0x78), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L3 ($30-$3F)
    rgb!(0xFC, 0xFC, 0xFC), rgb!(0xA4, 0xE4, 0xFC), rgb!(0xB8, 0xB8, 0xF8), rgb!(0xD8, 0xB8, 0xF8),
    rgb!(0xF8, 0xB8, 0xF8), rgb!(0xF8, 0xA4, 0xC0), rgb!(0xF0, 0xD0, 0xB0), rgb!(0xFC, 0xE0, 0xA8),
    rgb!(0xF8, 0xD8, 0x78), rgb!(0xD8, 0xF8, 0x78), rgb!(0xB8, 0xF8, 0xB8), rgb!(0xB8, 0xF8, 0xD8),
    rgb!(0x00, 0xFC, 0xFC), rgb!(0xF8, 0xD8, 0xF8), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
];

#[rustfmt::skip]
const FBX_COMPOSITE_DIRECT_DATA: [Color; 64] = [
    // L0 ($00-$0F)
    rgb!(0x65, 0x65, 0x65), rgb!(0x00, 0x12, 0x7D), rgb!(0x18, 0x00, 0x8E), rgb!(0x36, 0x00, 0x82),
    rgb!(0x56, 0x00, 0x5D), rgb!(0x5A, 0x00, 0x18), rgb!(0x4F, 0x05, 0x00), rgb!(0x38, 0x19, 0x00),
    rgb!(0x1D, 0x31, 0x00), rgb!(0x00, 0x3D, 0x00), rgb!(0x00, 0x41, 0x00), rgb!(0x00, 0x3B, 0x17),
    rgb!(0x00, 0x2E, 0x55), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L1 ($10-$1F)
    rgb!(0xAF, 0xAF, 0xAF), rgb!(0x19, 0x4E, 0xC8), rgb!(0x47, 0x2F, 0xE3), rgb!(0x6B, 0x1F, 0xD7),
    rgb!(0x93, 0x1B, 0xAE), rgb!(0x9E, 0x1A, 0x5E), rgb!(0x99, 0x32, 0x00), rgb!(0x7B, 0x4B, 0x00),
    rgb!(0x5B, 0x67, 0x00), rgb!(0x26, 0x7A, 0x00), rgb!(0x00, 0x82, 0x00), rgb!(0x00, 0x7A, 0x3E),
    rgb!(0x00, 0x6E, 0x8A), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L2 ($20-$2F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0x64, 0xA9, 0xFF), rgb!(0x8E, 0x89, 0xFF), rgb!(0xB6, 0x76, 0xFF),
    rgb!(0xE0, 0x6F, 0xFF), rgb!(0xEF, 0x6C, 0xC4), rgb!(0xF0, 0x80, 0x6A), rgb!(0xD8, 0x98, 0x2C),
    rgb!(0xB9, 0xB4, 0x0A), rgb!(0x83, 0xCB, 0x0C), rgb!(0x5B, 0xD6, 0x3F), rgb!(0x4A, 0xD1, 0x7E),
    rgb!(0x4D, 0xC7, 0xCB), rgb!(0x4C, 0x4C, 0x4C), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L3 ($30-$3F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0xC7, 0xE5, 0xFF), rgb!(0xD9, 0xD9, 0xFF), rgb!(0xE9, 0xD1, 0xFF),
    rgb!(0xF9, 0xCE, 0xFF), rgb!(0xFF, 0xCC, 0xF1), rgb!(0xFF, 0xD4, 0xCB), rgb!(0xF8, 0xDF, 0xB1),
    rgb!(0xED, 0xEA, 0xA4), rgb!(0xD6, 0xF4, 0xA4), rgb!(0xC5, 0xF8, 0xB8), rgb!(0xBE, 0xF6, 0xD3),
    rgb!(0xBF, 0xF1, 0xF1), rgb!(0xB9, 0xB9, 0xB9), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
];

#[rustfmt::skip]
const SONY_CXA2025AS_US_DATA: [Color; 64] = [
    // L0 ($00-$0F)
    rgb!(0x58, 0x58, 0x58), rgb!(0x00, 0x23, 0x8C), rgb!(0x00, 0x13, 0x9B), rgb!(0x2D, 0x05, 0x85),
    rgb!(0x5D, 0x00, 0x52), rgb!(0x7A, 0x00, 0x17), rgb!(0x7A, 0x08, 0x00), rgb!(0x5F, 0x18, 0x00),
    rgb!(0x35, 0x2A, 0x00), rgb!(0x09, 0x39, 0x00), rgb!(0x00, 0x3F, 0x00), rgb!(0x00, 0x3C, 0x22),
    rgb!(0x00, 0x32, 0x5D), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L1 ($10-$1F)
    rgb!(0xA1, 0xA1, 0xA1), rgb!(0x00, 0x53, 0xEE), rgb!(0x15, 0x3C, 0xFE), rgb!(0x60, 0x28, 0xE4),
    rgb!(0xA9, 0x1D, 0x98), rgb!(0xD4, 0x1E, 0x41), rgb!(0xD2, 0x2C, 0x00), rgb!(0xAA, 0x44, 0x00),
    rgb!(0x6C, 0x5E, 0x00), rgb!(0x2D, 0x73, 0x00), rgb!(0x00, 0x7D, 0x06), rgb!(0x00, 0x78, 0x52),
    rgb!(0x00, 0x69, 0xA9), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L2 ($20-$2F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0x1F, 0xA5, 0xFE), rgb!(0x5E, 0x89, 0xFE), rgb!(0xB5, 0x72, 0xFE),
    rgb!(0xFE, 0x65, 0xF6), rgb!(0xFE, 0x67, 0x90), rgb!(0xFE, 0x77, 0x3C), rgb!(0xFE, 0x93, 0x08),
    rgb!(0xC4, 0xB2, 0x00), rgb!(0x79, 0xCA, 0x10), rgb!(0x3A, 0xD5, 0x4A), rgb!(0x11, 0xD1, 0xA4),
    rgb!(0x06, 0xBF, 0xFE), rgb!(0x42, 0x42, 0x42), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L3 ($30-$3F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0xA0, 0xD9, 0xFE), rgb!(0xBD, 0xCC, 0xFE), rgb!(0xE1, 0xC2, 0xFE),
    rgb!(0xFE, 0xBC, 0xFB), rgb!(0xFE, 0xBD, 0xD0), rgb!(0xFE, 0xC5, 0xA9), rgb!(0xFE, 0xD1, 0x8E),
    rgb!(0xE9, 0xDE, 0x86), rgb!(0xC7, 0xE9, 0x92), rgb!(0xA8, 0xEE, 0xB0), rgb!(0x95, 0xEC, 0xD9),
    rgb!(0x91, 0xE4, 0xFE), rgb!(0xAC, 0xAC, 0xAC), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
];

#[rustfmt::skip]
const PAL_2C07_DATA: [Color; 64] = [
    // L0 ($00-$0F)
    rgb!(0x5A, 0x61, 0x65), rgb!(0x00, 0x23, 0xA8), rgb!(0x0F, 0x17, 0xB0), rgb!(0x28, 0x12, 0x9F),
    rgb!(0x55, 0x0B, 0x61), rgb!(0x6B, 0x0A, 0x11), rgb!(0x6E, 0x0D, 0x00), rgb!(0x5E, 0x19, 0x00),
    rgb!(0x3C, 0x24, 0x02), rgb!(0x00, 0x31, 0x04), rgb!(0x00, 0x35, 0x08), rgb!(0x00, 0x34, 0x1F),
    rgb!(0x00, 0x2C, 0x55), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L1 ($10-$1F)
    rgb!(0xA7, 0xB5, 0xBC), rgb!(0x00, 0x59, 0xFF), rgb!(0x2A, 0x44, 0xFF), rgb!(0x52, 0x3C, 0xF1),
    rgb!(0x9F, 0x34, 0xBA), rgb!(0xB3, 0x28, 0x46), rgb!(0xBB, 0x2D, 0x09), rgb!(0x9E, 0x41, 0x00),
    rgb!(0x86, 0x5A, 0x00), rgb!(0x24, 0x6D, 0x02), rgb!(0x00, 0x73, 0x12), rgb!(0x00, 0x71, 0x56),
    rgb!(0x00, 0x66, 0xA6), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L2 ($20-$2F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0x4B, 0x9F, 0xFF), rgb!(0x5A, 0x91, 0xFF), rgb!(0x86, 0x7E, 0xFF),
    rgb!(0xD9, 0x7D, 0xFF), rgb!(0xFF, 0x95, 0xCF), rgb!(0xFF, 0x8E, 0x76), rgb!(0xF7, 0xA2, 0x47),
    rgb!(0xEF, 0xB4, 0x12), rgb!(0x8C, 0xC5, 0x1C), rgb!(0x48, 0xD0, 0x4A), rgb!(0x10, 0xD1, 0x97),
    rgb!(0x00, 0xC9, 0xF0), rgb!(0x43, 0x48, 0x4B), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L3 ($30-$3F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0xB1, 0xD9, 0xFF), rgb!(0xB1, 0xCF, 0xFF), rgb!(0xBC, 0xC8, 0xFF),
    rgb!(0xE3, 0xC8, 0xFF), rgb!(0xFF, 0xD3, 0xF7), rgb!(0xFF, 0xD5, 0xCB), rgb!(0xFF, 0xDE, 0xB9),
    rgb!(0xFF, 0xE5, 0xAD), rgb!(0xDB, 0xF6, 0xAF), rgb!(0xB7, 0xFB, 0xC4), rgb!(0x9C, 0xFB, 0xE6),
    rgb!(0x96, 0xF7, 0xFF), rgb!(0xB1, 0xC0, 0xC7), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
];

// Raw-linear palette derived from the classic YIQ→RGB matrix without decoder tuning.
#[rustfmt::skip]
const RAW_LINEAR_DATA: [Color; 64] = [
    // L0 ($00-$0F)
    rgb!(0x66, 0x66, 0x66), rgb!(0x02, 0x1E, 0x9C), rgb!(0x28, 0x08, 0xAB), rgb!(0x4D, 0x00, 0x95),
    rgb!(0x67, 0x00, 0x61), rgb!(0x6F, 0x00, 0x1D), rgb!(0x62, 0x11, 0x00), rgb!(0x45, 0x29, 0x00),
    rgb!(0x1F, 0x3F, 0x00), rgb!(0x00, 0x4E, 0x00), rgb!(0x00, 0x51, 0x00), rgb!(0x00, 0x49, 0x2B),
    rgb!(0x00, 0x36, 0x6D), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L1 ($10-$1F)
    rgb!(0xAD, 0xAD, 0xAD), rgb!(0x2B, 0x50, 0xF4), rgb!(0x5C, 0x33, 0xFF), rgb!(0x8D, 0x20, 0xEB),
    rgb!(0xAF, 0x1B, 0xA7), rgb!(0xB9, 0x27, 0x4E), rgb!(0xA9, 0x3F, 0x00), rgb!(0x83, 0x5E, 0x00),
    rgb!(0x51, 0x7B, 0x00), rgb!(0x21, 0x8E, 0x00), rgb!(0x00, 0x92, 0x06), rgb!(0x00, 0x87, 0x60),
    rgb!(0x05, 0x6F, 0xB7), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L2 ($20-$2F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0x7A, 0xA0, 0xFF), rgb!(0xAD, 0x83, 0xFF), rgb!(0xDE, 0x6F, 0xFF),
    rgb!(0xFF, 0x6B, 0xF8), rgb!(0xFF, 0x76, 0x9E), rgb!(0xFA, 0x8F, 0x46), rgb!(0xD4, 0xAE, 0x07),
    rgb!(0xA1, 0xCB, 0x00), rgb!(0x70, 0xDF, 0x11), rgb!(0x4E, 0xE4, 0x56), rgb!(0x43, 0xD8, 0xB0),
    rgb!(0x54, 0xBF, 0xFF), rgb!(0x4F, 0x4F, 0x4F), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
    // L3 ($30-$3F)
    rgb!(0xFF, 0xFF, 0xFF), rgb!(0xC9, 0xD8, 0xFF), rgb!(0xDE, 0xCD, 0xFF), rgb!(0xF2, 0xC5, 0xFF),
    rgb!(0xFF, 0xC3, 0xFC), rgb!(0xFF, 0xC7, 0xD8), rgb!(0xFD, 0xD1, 0xB4), rgb!(0xED, 0xDE, 0x9B),
    rgb!(0xD9, 0xEA, 0x93), rgb!(0xC5, 0xF2, 0x9E), rgb!(0xB7, 0xF4, 0xBA), rgb!(0xB3, 0xEF, 0xDF),
    rgb!(0xB9, 0xE5, 0xFF), rgb!(0xB8, 0xB8, 0xB8), rgb!(0x00, 0x00, 0x00), rgb!(0x00, 0x00, 0x00),
];

#[cfg(test)]
mod tests {
    use super::*;

    fn digest(colors: &[Color; 64]) -> u128 {
        colors.iter().fold(0u128, |acc, color| {
            let value = ((color.r as u128) << 16) | ((color.g as u128) << 8) | (color.b as u128);
            acc.wrapping_mul(257).wrapping_add(value)
        })
    }

    fn compute_raw_linear_reference() -> [Color; 64] {
        const LEVELS_LOW: [f64; 4] = [-0.12, 0.0, 0.31, 0.72];
        const LEVELS_HIGH: [f64; 4] = [0.40, 0.68, 1.0, 1.0];
        let mut table = [Color::BLACK; 64];
        let mut idx = 0;
        while idx < 64 {
            let intensity = (idx >> 4) & 3;
            let mut low = LEVELS_LOW[intensity];
            let mut high = LEVELS_HIGH[intensity];
            let hue = idx & 0x0F;
            if hue == 0x00 {
                low = high;
            } else if hue == 0x0D {
                high = low;
            } else if hue >= 0x0E {
                low = 0.0;
                high = 0.0;
            }
            let y = (high + low) * 0.5;
            let s = (high - low) * 0.5;
            let angle = core::f64::consts::PI / 6.0 * ((hue as f64) - 3.0);
            let i = angle.sin() * s;
            let q = angle.cos() * s;
            // Convert YIQ to RGB using the standard matrix.
            let r = y + 0.946_882 * i + 0.623_557 * q;
            let g = y - 0.274_788 * i - 0.635_691 * q;
            let b = y - 1.108_545 * i + 1.709_007 * q;
            table[idx] = Color::new(clamp_to_byte(r), clamp_to_byte(g), clamp_to_byte(b));
            idx += 1;
        }
        table
    }

    fn clamp_to_byte(value: f64) -> u8 {
        let scaled = (value * 255.0).round();
        scaled.clamp(0.0, 255.0) as u8
    }

    #[test]
    fn nesdev_palette_hash_matches_reference() {
        assert_eq!(
            digest(&NESDEV_TABLE),
            293284693531907907797025226402075421020
        );
    }

    #[test]
    fn fbx_composite_palette_hash_matches_reference() {
        assert_eq!(
            digest(&FBX_COMPOSITE_DIRECT_DATA),
            88560908037763379911532392017758831100
        );
    }

    #[test]
    fn sony_cxa_palette_hash_matches_reference() {
        assert_eq!(
            digest(&SONY_CXA2025AS_US_DATA),
            13858308463939229359884757179859315326
        );
    }

    #[test]
    fn pal_2c07_palette_hash_matches_reference() {
        assert_eq!(
            digest(&PAL_2C07_DATA),
            137530699331335644888413584262451297831
        );
    }

    #[test]
    fn raw_linear_palette_matches_generated_reference() {
        let generated = compute_raw_linear_reference();
        assert_eq!(RAW_LINEAR_DATA, generated);
    }
}
