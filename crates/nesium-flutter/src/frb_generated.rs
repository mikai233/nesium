// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{Lifetimeable, Lockable, transform_result_dco};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1544340456;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__events__aux_texture_ids_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "aux_texture_ids",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::events::aux_texture_ids().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__gamepad__bind_gamepad_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "bind_gamepad",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <u64>::sse_decode(&mut deserializer);
            let api_port = <Option<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::bind_gamepad(api_id, api_port)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__debug_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "debug_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::DebugStateNotification,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::debug_state_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__emulation_status_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "emulation_status_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::EmulationStatusNotification,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::emulation_status_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__gamepad__gamepad_actions_ffi_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gamepad_actions_ffi_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::gamepad::GamepadActionsFfi::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__gamepad_poll_result_ffi_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "gamepad_poll_result_ffi_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::gamepad::GamepadPollResultFfi::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__get_gamepad_mapping_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_gamepad_mapping",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_port = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::get_gamepad_mapping(api_port)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__get_gamepad_pressed_buttons_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_gamepad_pressed_buttons",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_id = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::get_gamepad_pressed_buttons(api_id)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__net_utils__get_local_addrs_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_local_addrs",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::net_utils::get_local_addrs())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__net_utils__get_public_ip_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_public_ip",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::net_utils::get_public_ip())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__load_rom__get_rom_hash_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_rom_hash",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::load_rom::get_rom_hash())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__server__get_server_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_server",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::server::get_server();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__simple__greet_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "greet",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::simple::greet(api_name))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__simple__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::simple::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__simple__init_app_paths_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app_paths",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data_dir = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::simple::init_app_paths(api_data_dir);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__gamepad__init_gamepad_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_gamepad",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::init_gamepad()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__pause__is_paused_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "is_paused",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::pause::is_paused())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__lcd_grid_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lcd_grid_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::video::LcdGridOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__list_gamepads_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "list_gamepads",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::list_gamepads()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__load_rom__load_rom_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_rom",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::load_rom::load_rom(api_path)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__load_rom__load_rom_from_bytes_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_rom_from_bytes",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::load_rom::load_rom_from_bytes(api_bytes)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__load_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::emulation::load_state(api_path)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__load_state_from_memory_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_state_from_memory",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::emulation::load_state_from_memory(api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__emulation__load_tas_movie_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "load_tas_movie",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::emulation::load_tas_movie(api_data)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_connect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_connect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_addr = <String>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::netplay::netplay_connect(api_server_addr, api_player_name)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_connect_auto_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_connect_auto",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_addr = <String>::sse_decode(&mut deserializer);
            let api_server_name = <String>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_connect_auto(
                            api_server_addr,
                            api_server_name,
                            api_player_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_connect_auto_pinned_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_connect_auto_pinned",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_addr = <String>::sse_decode(&mut deserializer);
            let api_server_name = <String>::sse_decode(&mut deserializer);
            let api_pinned_sha256_fingerprint = <String>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_connect_auto_pinned(
                            api_server_addr,
                            api_server_name,
                            api_pinned_sha256_fingerprint,
                            api_player_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_connect_quic_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_connect_quic",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_addr = <String>::sse_decode(&mut deserializer);
            let api_server_name = <String>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_connect_quic(
                            api_server_addr,
                            api_server_name,
                            api_player_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_connect_quic_pinned_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_connect_quic_pinned",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_server_addr = <String>::sse_decode(&mut deserializer);
            let api_server_name = <String>::sse_decode(&mut deserializer);
            let api_pinned_sha256_fingerprint = <String>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_connect_quic_pinned(
                            api_server_addr,
                            api_server_name,
                            api_pinned_sha256_fingerprint,
                            api_player_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_create_room_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_create_room",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_create_room().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_disconnect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_disconnect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_disconnect().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_game_event_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_game_event_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::netplay::NetplayGameEvent,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::netplay::netplay_game_event_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_is_connected_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_is_connected",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, ()>(
                    (move || async move {
                        let output_ok =
                            Result::<_, ()>::Ok(crate::api::netplay::netplay_is_connected().await)?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_join_room_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_join_room",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_room_code = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::netplay::netplay_join_room(api_room_code).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_p2p_connect_join_auto_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_p2p_connect_join_auto",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signaling_addr = <String>::sse_decode(&mut deserializer);
            let api_relay_addr = <String>::sse_decode(&mut deserializer);
            let api_room_code = <u32>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_p2p_connect_join_auto(
                            api_signaling_addr,
                            api_relay_addr,
                            api_room_code,
                            api_player_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_p2p_create_room_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_p2p_create_room",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signaling_addr = <String>::sse_decode(&mut deserializer);
            let api_host_addrs = <Vec<String>>::sse_decode(&mut deserializer);
            let api_host_room_code = <u32>::sse_decode(&mut deserializer);
            let api_host_quic_cert_sha256_fingerprint =
                <Option<String>>::sse_decode(&mut deserializer);
            let api_host_quic_server_name = <Option<String>>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_p2p_create_room(
                            api_signaling_addr,
                            api_host_addrs,
                            api_host_room_code,
                            api_host_quic_cert_sha256_fingerprint,
                            api_host_quic_server_name,
                            api_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_p2p_host_create_and_watch_fallback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_p2p_host_create_and_watch_fallback",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signaling_addr = <String>::sse_decode(&mut deserializer);
            let api_relay_addr = <String>::sse_decode(&mut deserializer);
            let api_host_addrs = <Vec<String>>::sse_decode(&mut deserializer);
            let api_host_room_code = <u32>::sse_decode(&mut deserializer);
            let api_host_quic_cert_sha256_fingerprint =
                <Option<String>>::sse_decode(&mut deserializer);
            let api_host_quic_server_name = <Option<String>>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::netplay::netplay_p2p_host_create_and_watch_fallback(
                                api_signaling_addr,
                                api_relay_addr,
                                api_host_addrs,
                                api_host_room_code,
                                api_host_quic_cert_sha256_fingerprint,
                                api_host_quic_server_name,
                                api_player_name,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_p2p_host_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_p2p_host_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signaling_addr = <String>::sse_decode(&mut deserializer);
            let api_relay_addr = <String>::sse_decode(&mut deserializer);
            let api_player_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_p2p_host_start(
                            api_signaling_addr,
                            api_relay_addr,
                            api_player_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_p2p_join_room_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_p2p_join_room",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signaling_addr = <String>::sse_decode(&mut deserializer);
            let api_room_code = <u32>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_p2p_join_room(
                            api_signaling_addr,
                            api_room_code,
                            api_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_p2p_request_fallback_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_p2p_request_fallback",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_signaling_addr = <String>::sse_decode(&mut deserializer);
            let api_room_code = <u32>::sse_decode(&mut deserializer);
            let api_reason = <String>::sse_decode(&mut deserializer);
            let api_name = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_p2p_request_fallback(
                            api_signaling_addr,
                            api_room_code,
                            api_reason,
                            api_name,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_provide_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_provide_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_frame = <u32>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::netplay::netplay_provide_state(api_frame, api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_request_fallback_relay_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_request_fallback_relay",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_relay_addr = <String>::sse_decode(&mut deserializer);
            let api_relay_room_code = <u32>::sse_decode(&mut deserializer);
            let api_reason = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_request_fallback_relay(
                            api_relay_addr,
                            api_relay_room_code,
                            api_reason,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_request_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_request_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_request_state().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_send_pause_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_send_pause",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_paused = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_send_pause(api_paused).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_send_reset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_send_reset",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_send_reset(api_kind).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_send_rom_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_send_rom",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_send_rom(api_data).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_send_rom_loaded_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_send_rom_loaded",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_send_rom_loaded().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_status_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_status_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::netplay::NetplayStatus,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::netplay::netplay_status_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__netplay__netplay_switch_role_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netplay_switch_role",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_role = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::netplay::netplay_switch_role(api_role).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__server__netserver_get_port_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netserver_get_port",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::server::netserver_get_port())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__server__netserver_is_running_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netserver_is_running",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::server::netserver_is_running())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__server__netserver_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netserver_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_port = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::server::netserver_start(api_port).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__server__netserver_status_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netserver_status_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::server::ServerStatus,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::server::netserver_status_stream(api_sink)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__server__netserver_stop_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "netserver_stop",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::server::netserver_stop().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__video__ntsc_bisqwit_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ntsc_bisqwit_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::video::NtscBisqwitOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__ntsc_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ntsc_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::video::NtscOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__palette__palette_presets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "palette_presets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::palette::palette_presets())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__palette_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "palette_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::PaletteSnapshot,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::palette_state_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__gamepad__poll_gamepads_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "poll_gamepads",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::poll_gamepads()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__load_rom__power_off_console_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "power_off_console",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::load_rom::power_off_console()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__load_rom__power_reset_console_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "power_reset_console",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::load_rom::power_reset_console()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__replay_event_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "replay_event_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::senders::replay::ReplayEventNotification,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::replay_event_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__load_rom__reset_console_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "reset_console",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::load_rom::reset_console()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__rumble_gamepad_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "rumble_gamepad",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_port = <u8>::sse_decode(&mut deserializer);
            let api_strength = <f32>::sse_decode(&mut deserializer);
            let api_duration_ms = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::gamepad::rumble_gamepad(
                        api_port,
                        api_strength,
                        api_duration_ms,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__runtime_notifications_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "runtime_notifications",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::RuntimeNotification,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::runtime_notifications(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__emulation__save_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::emulation::save_state(api_path)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__save_state_to_memory_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "save_state_to_memory",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::emulation::save_state_to_memory().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__video__scanline_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "scanline_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::video::ScanlineOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__set_fast_forward_speed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_fast_forward_speed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_speed_percent = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::emulation::set_fast_forward_speed(api_speed_percent)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__set_fast_forwarding_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_fast_forwarding",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_fast_forwarding = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::emulation::set_fast_forwarding(api_fast_forwarding)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__set_gamepad_mapping_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_gamepad_mapping",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_port = <u8>::sse_decode(&mut deserializer);
            let api_mapping =
                <crate::api::gamepad::GamepadMappingFfi>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::gamepad::set_gamepad_mapping(api_port, api_mapping)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__set_integer_fps_mode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_integer_fps_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::emulation::set_integer_fps_mode(api_enabled)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_lcd_grid_options_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_lcd_grid_options",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options = <crate::api::video::LcdGridOptions>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_lcd_grid_options(api_options)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_ntsc_bisqwit_options_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_ntsc_bisqwit_options",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options =
                <crate::api::video::NtscBisqwitOptions>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_ntsc_bisqwit_options(api_options)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_ntsc_options_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_ntsc_options",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options = <crate::api::video::NtscOptions>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_ntsc_options(api_options)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__input__set_pad_mask_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_pad_mask",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pad = <u8>::sse_decode(&mut deserializer);
            let api_mask = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::input::set_pad_mask(api_pad, api_mask)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__set_palette_capture_frame_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_palette_capture_frame_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_palette_capture_frame_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_palette_capture_scanline_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_palette_capture_scanline",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_scanline = <i32>::sse_decode(&mut deserializer);
            let api_dot = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_palette_capture_scanline(api_scanline, api_dot)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_palette_capture_vblank_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_palette_capture_vblank_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_palette_capture_vblank_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__palette__set_palette_pal_data_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_palette_pal_data",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::palette::set_palette_pal_data(api_data)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__palette__set_palette_preset_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_palette_preset",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_kind = <crate::api::palette::PaletteKind>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::palette::set_palette_preset(api_kind)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__pause__set_paused_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_paused",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_paused = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::pause::set_paused(api_paused);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__set_rewind_config_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rewind_config",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            let api_capacity = <u64>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::emulation::set_rewind_config(api_enabled, api_capacity)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__set_rewind_speed_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rewind_speed",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_speed_percent = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::emulation::set_rewind_speed(api_speed_percent)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__emulation__set_rewinding_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_rewinding",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_rewinding = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::emulation::set_rewinding(api_rewinding)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_scanline_options_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_scanline_options",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_options = <crate::api::video::ScanlineOptions>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_scanline_options(api_options)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_shader_enabled_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_shader_enabled",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_enabled = <bool>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_shader_enabled(api_enabled)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_shader_preset_path_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_shader_preset_path",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_path = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_shader_preset_path(api_path)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__set_sprite_capture_frame_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_sprite_capture_frame_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_sprite_capture_frame_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_sprite_capture_scanline_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_sprite_capture_scanline",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_scanline = <i32>::sse_decode(&mut deserializer);
            let api_dot = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_sprite_capture_scanline(api_scanline, api_dot)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_sprite_capture_vblank_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_sprite_capture_vblank_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_sprite_capture_vblank_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_background_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_background",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_background = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_background(api_background).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_capture_frame_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_capture_frame_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_capture_frame_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_capture_scanline_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_capture_scanline",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_scanline = <i32>::sse_decode(&mut deserializer);
            let api_dot = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::set_tile_viewer_capture_scanline(
                            api_scanline,
                            api_dot,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_capture_vblank_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_capture_vblank_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_capture_vblank_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_display_mode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_display_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mode = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_display_mode(api_mode).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_layout_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_layout",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_layout = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_layout(api_layout).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_palette_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_palette",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_palette_index = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_palette(api_palette_index).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_columns = <u16>::sse_decode(&mut deserializer);
            let api_rows = <u16>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_size(api_columns, api_rows).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_source_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_source",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_source = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_source(api_source).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tile_viewer_start_address_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tile_viewer_start_address",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_start_address = <u32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tile_viewer_start_address(api_start_address)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tilemap_capture_frame_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tilemap_capture_frame_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tilemap_capture_frame_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tilemap_capture_scanline_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tilemap_capture_scanline",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_scanline = <i32>::sse_decode(&mut deserializer);
            let api_dot = <i32>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tilemap_capture_scanline(api_scanline, api_dot)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tilemap_capture_vblank_start_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tilemap_capture_vblank_start",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tilemap_capture_vblank_start().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__set_tilemap_display_mode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_tilemap_display_mode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_mode = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok =
                            crate::api::events::set_tilemap_display_mode(api_mode).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__input__set_turbo_frames_per_toggle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_turbo_frames_per_toggle",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_frames = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::input::set_turbo_frames_per_toggle(api_frames)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__input__set_turbo_mask_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_turbo_mask",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_pad = <u8>::sse_decode(&mut deserializer);
            let api_mask = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::input::set_turbo_mask(api_pad, api_mask)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__input__set_turbo_timing_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_turbo_timing",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_on_frames = <u8>::sse_decode(&mut deserializer);
            let api_off_frames = <u8>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok =
                        crate::api::input::set_turbo_timing(api_on_frames, api_off_frames)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__video__set_video_filter_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "set_video_filter",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_filter = <crate::api::video::VideoFilter>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::video::set_video_filter(api_filter)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__gamepad__shutdown_gamepad_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "shutdown_gamepad",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::gamepad::shutdown_gamepad();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__sprite_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "sprite_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::SpriteSnapshot,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::sprite_state_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__load_rom__start_nes_runtime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "start_nes_runtime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, String>((move || {
                    let output_ok = crate::api::load_rom::start_nes_runtime()?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__subscribe_tilemap_texture_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "subscribe_tilemap_texture",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::subscribe_tilemap_texture().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__tile_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tile_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::TileSnapshot,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::tile_state_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__tilemap_state_stream_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tilemap_state_stream",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_sink = <StreamSink<
                crate::api::events::TilemapSnapshot,
                flutter_rust_bridge::for_generated::SseCodec,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::tilemap_state_stream(api_sink).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__pause__toggle_pause_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "toggle_pause",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::pause::toggle_pause())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__net_utils__try_upnp_mapping_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "try_upnp_mapping",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api__port = <u16>::sse_decode(&mut deserializer);
            let api__label_prefix = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::net_utils::try_upnp_mapping(api__port, &api__label_prefix);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__events__unsubscribe_debug_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unsubscribe_debug_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::unsubscribe_debug_state().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__unsubscribe_palette_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unsubscribe_palette_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::unsubscribe_palette_state().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__unsubscribe_sprite_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unsubscribe_sprite_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::unsubscribe_sprite_state().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__unsubscribe_tile_state_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unsubscribe_tile_state",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::unsubscribe_tile_state().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__events__unsubscribe_tilemap_texture_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "unsubscribe_tilemap_texture",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, String>(
                    (move || async move {
                        let output_ok = crate::api::events::unsubscribe_tilemap_texture().await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::events::DebugStateNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::events::EmulationStatusNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::netplay::NetplayGameEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::netplay::NetplayStatus, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::events::PaletteSnapshot,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::senders::replay::ReplayEventNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::events::RuntimeNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::server::ServerStatus, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::events::SpriteSnapshot, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<crate::api::events::TileSnapshot, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode
    for StreamSink<
        crate::api::events::TilemapSnapshot,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return StreamSink::deserialize(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::events::AuxTextureIds {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_tilemap = <u32>::sse_decode(deserializer);
        let mut var_tile = <u32>::sse_decode(deserializer);
        let mut var_sprite = <u32>::sse_decode(deserializer);
        let mut var_spriteScreen = <u32>::sse_decode(deserializer);
        return crate::api::events::AuxTextureIds {
            tilemap: var_tilemap,
            tile: var_tile,
            sprite: var_sprite,
            sprite_screen: var_spriteScreen,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::events::DebugStateNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_cpuPc = <u16>::sse_decode(deserializer);
        let mut var_cpuA = <u8>::sse_decode(deserializer);
        let mut var_cpuX = <u8>::sse_decode(deserializer);
        let mut var_cpuY = <u8>::sse_decode(deserializer);
        let mut var_cpuSp = <u8>::sse_decode(deserializer);
        let mut var_cpuStatus = <u8>::sse_decode(deserializer);
        let mut var_cpuCycle = <u64>::sse_decode(deserializer);
        let mut var_ppuScanline = <i16>::sse_decode(deserializer);
        let mut var_ppuCycle = <u16>::sse_decode(deserializer);
        let mut var_ppuFrame = <u32>::sse_decode(deserializer);
        let mut var_ppuCtrl = <u8>::sse_decode(deserializer);
        let mut var_ppuMask = <u8>::sse_decode(deserializer);
        let mut var_ppuStatus = <u8>::sse_decode(deserializer);
        return crate::api::events::DebugStateNotification {
            cpu_pc: var_cpuPc,
            cpu_a: var_cpuA,
            cpu_x: var_cpuX,
            cpu_y: var_cpuY,
            cpu_sp: var_cpuSp,
            cpu_status: var_cpuStatus,
            cpu_cycle: var_cpuCycle,
            ppu_scanline: var_ppuScanline,
            ppu_cycle: var_ppuCycle,
            ppu_frame: var_ppuFrame,
            ppu_ctrl: var_ppuCtrl,
            ppu_mask: var_ppuMask,
            ppu_status: var_ppuStatus,
        };
    }
}

impl SseDecode for crate::api::events::EmulationStatusNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_paused = <bool>::sse_decode(deserializer);
        let mut var_rewinding = <bool>::sse_decode(deserializer);
        let mut var_fastForwarding = <bool>::sse_decode(deserializer);
        return crate::api::events::EmulationStatusNotification {
            paused: var_paused,
            rewinding: var_rewinding,
            fast_forwarding: var_fastForwarding,
        };
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::gamepad::GamepadActionsFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_rewind = <bool>::sse_decode(deserializer);
        let mut var_fastForward = <bool>::sse_decode(deserializer);
        let mut var_saveState = <bool>::sse_decode(deserializer);
        let mut var_loadState = <bool>::sse_decode(deserializer);
        let mut var_pause = <bool>::sse_decode(deserializer);
        return crate::api::gamepad::GamepadActionsFfi {
            rewind: var_rewind,
            fast_forward: var_fastForward,
            save_state: var_saveState,
            load_state: var_loadState,
            pause: var_pause,
        };
    }
}

impl SseDecode for crate::api::gamepad::GamepadButtonFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::gamepad::GamepadButtonFfi::South,
            1 => crate::api::gamepad::GamepadButtonFfi::East,
            2 => crate::api::gamepad::GamepadButtonFfi::North,
            3 => crate::api::gamepad::GamepadButtonFfi::West,
            4 => crate::api::gamepad::GamepadButtonFfi::C,
            5 => crate::api::gamepad::GamepadButtonFfi::Z,
            6 => crate::api::gamepad::GamepadButtonFfi::LeftTrigger,
            7 => crate::api::gamepad::GamepadButtonFfi::LeftTrigger2,
            8 => crate::api::gamepad::GamepadButtonFfi::RightTrigger,
            9 => crate::api::gamepad::GamepadButtonFfi::RightTrigger2,
            10 => crate::api::gamepad::GamepadButtonFfi::Select,
            11 => crate::api::gamepad::GamepadButtonFfi::Start,
            12 => crate::api::gamepad::GamepadButtonFfi::Mode,
            13 => crate::api::gamepad::GamepadButtonFfi::LeftThumb,
            14 => crate::api::gamepad::GamepadButtonFfi::RightThumb,
            15 => crate::api::gamepad::GamepadButtonFfi::DPadUp,
            16 => crate::api::gamepad::GamepadButtonFfi::DPadDown,
            17 => crate::api::gamepad::GamepadButtonFfi::DPadLeft,
            18 => crate::api::gamepad::GamepadButtonFfi::DPadRight,
            19 => crate::api::gamepad::GamepadButtonFfi::Unknown,
            _ => unreachable!("Invalid variant for GamepadButtonFfi: {}", inner),
        };
    }
}

impl SseDecode for crate::api::gamepad::GamepadInfoFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <u64>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_connected = <bool>::sse_decode(deserializer);
        let mut var_port = <Option<u8>>::sse_decode(deserializer);
        return crate::api::gamepad::GamepadInfoFfi {
            id: var_id,
            name: var_name,
            connected: var_connected,
            port: var_port,
        };
    }
}

impl SseDecode for crate::api::gamepad::GamepadMappingFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_a = <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_b = <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_select =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_start =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_up = <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_down =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_left =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_right =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_turboA =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_turboB =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_rewind =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_fastForward =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_saveState =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_loadState =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        let mut var_pause =
            <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_decode(deserializer);
        return crate::api::gamepad::GamepadMappingFfi {
            a: var_a,
            b: var_b,
            select: var_select,
            start: var_start,
            up: var_up,
            down: var_down,
            left: var_left,
            right: var_right,
            turbo_a: var_turboA,
            turbo_b: var_turboB,
            rewind: var_rewind,
            fast_forward: var_fastForward,
            save_state: var_saveState,
            load_state: var_loadState,
            pause: var_pause,
        };
    }
}

impl SseDecode for crate::api::gamepad::GamepadPollResultFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_padMasks = <Vec<u8>>::sse_decode(deserializer);
        let mut var_turboMasks = <Vec<u8>>::sse_decode(deserializer);
        let mut var_actions = <crate::api::gamepad::GamepadActionsFfi>::sse_decode(deserializer);
        return crate::api::gamepad::GamepadPollResultFfi {
            pad_masks: var_padMasks,
            turbo_masks: var_turboMasks,
            actions: var_actions,
        };
    }
}

impl SseDecode for i16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::video::LcdGridOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_strength = <f64>::sse_decode(deserializer);
        return crate::api::video::LcdGridOptions {
            strength: var_strength,
        };
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::gamepad::GamepadButtonFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::gamepad::GamepadButtonFfi>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::gamepad::GamepadInfoFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::gamepad::GamepadInfoFfi>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::netplay::NetplayPlayer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::netplay::NetplayPlayer>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::palette::PalettePresetInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::palette::PalettePresetInfo>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::events::SpriteInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::events::SpriteInfo>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::netplay::NetplayGameEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_data = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::LoadRom { data: var_data };
            }
            1 => {
                return crate::api::netplay::NetplayGameEvent::StartGame;
            }
            2 => {
                let mut var_paused = <bool>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::PauseSync { paused: var_paused };
            }
            3 => {
                let mut var_kind = <u8>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::ResetSync { kind: var_kind };
            }
            4 => {
                let mut var_frame = <u32>::sse_decode(deserializer);
                let mut var_data = <Vec<u8>>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::SyncState {
                    frame: var_frame,
                    data: var_data,
                };
            }
            5 => {
                let mut var_playerIndex = <u8>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::PlayerLeft {
                    player_index: var_playerIndex,
                };
            }
            6 => {
                let mut var_errorCode = <u16>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::Error {
                    error_code: var_errorCode,
                };
            }
            7 => {
                let mut var_relayAddr = <String>::sse_decode(deserializer);
                let mut var_relayRoomCode = <u32>::sse_decode(deserializer);
                let mut var_reason = <String>::sse_decode(deserializer);
                return crate::api::netplay::NetplayGameEvent::FallbackToRelay {
                    relay_addr: var_relayAddr,
                    relay_room_code: var_relayRoomCode,
                    reason: var_reason,
                };
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::netplay::NetplayPlayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_clientId = <u32>::sse_decode(deserializer);
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_playerIndex = <u8>::sse_decode(deserializer);
        return crate::api::netplay::NetplayPlayer {
            client_id: var_clientId,
            name: var_name,
            player_index: var_playerIndex,
        };
    }
}

impl SseDecode for crate::api::netplay::NetplayState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::netplay::NetplayState::Disconnected,
            1 => crate::api::netplay::NetplayState::Connecting,
            2 => crate::api::netplay::NetplayState::Connected,
            3 => crate::api::netplay::NetplayState::InRoom,
            _ => unreachable!("Invalid variant for NetplayState: {}", inner),
        };
    }
}

impl SseDecode for crate::api::netplay::NetplayStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_state = <crate::api::netplay::NetplayState>::sse_decode(deserializer);
        let mut var_transport = <crate::api::netplay::NetplayTransport>::sse_decode(deserializer);
        let mut var_tcpFallbackFromQuic = <bool>::sse_decode(deserializer);
        let mut var_clientId = <u32>::sse_decode(deserializer);
        let mut var_roomId = <u32>::sse_decode(deserializer);
        let mut var_playerIndex = <u8>::sse_decode(deserializer);
        let mut var_players = <Vec<crate::api::netplay::NetplayPlayer>>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::api::netplay::NetplayStatus {
            state: var_state,
            transport: var_transport,
            tcp_fallback_from_quic: var_tcpFallbackFromQuic,
            client_id: var_clientId,
            room_id: var_roomId,
            player_index: var_playerIndex,
            players: var_players,
            error: var_error,
        };
    }
}

impl SseDecode for crate::api::netplay::NetplayTransport {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::netplay::NetplayTransport::Unknown,
            1 => crate::api::netplay::NetplayTransport::Tcp,
            2 => crate::api::netplay::NetplayTransport::Quic,
            _ => unreachable!("Invalid variant for NetplayTransport: {}", inner),
        };
    }
}

impl SseDecode for crate::api::video::NtscBisqwitOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_brightness = <f64>::sse_decode(deserializer);
        let mut var_contrast = <f64>::sse_decode(deserializer);
        let mut var_hue = <f64>::sse_decode(deserializer);
        let mut var_saturation = <f64>::sse_decode(deserializer);
        let mut var_yFilterLength = <f64>::sse_decode(deserializer);
        let mut var_iFilterLength = <f64>::sse_decode(deserializer);
        let mut var_qFilterLength = <f64>::sse_decode(deserializer);
        return crate::api::video::NtscBisqwitOptions {
            brightness: var_brightness,
            contrast: var_contrast,
            hue: var_hue,
            saturation: var_saturation,
            y_filter_length: var_yFilterLength,
            i_filter_length: var_iFilterLength,
            q_filter_length: var_qFilterLength,
        };
    }
}

impl SseDecode for crate::api::video::NtscOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_hue = <f64>::sse_decode(deserializer);
        let mut var_saturation = <f64>::sse_decode(deserializer);
        let mut var_contrast = <f64>::sse_decode(deserializer);
        let mut var_brightness = <f64>::sse_decode(deserializer);
        let mut var_sharpness = <f64>::sse_decode(deserializer);
        let mut var_gamma = <f64>::sse_decode(deserializer);
        let mut var_resolution = <f64>::sse_decode(deserializer);
        let mut var_artifacts = <f64>::sse_decode(deserializer);
        let mut var_fringing = <f64>::sse_decode(deserializer);
        let mut var_bleed = <f64>::sse_decode(deserializer);
        let mut var_mergeFields = <bool>::sse_decode(deserializer);
        return crate::api::video::NtscOptions {
            hue: var_hue,
            saturation: var_saturation,
            contrast: var_contrast,
            brightness: var_brightness,
            sharpness: var_sharpness,
            gamma: var_gamma,
            resolution: var_resolution,
            artifacts: var_artifacts,
            fringing: var_fringing,
            bleed: var_bleed,
            merge_fields: var_mergeFields,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::gamepad::GamepadButtonFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::gamepad::GamepadButtonFfi>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u8>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::netplay::P2PConnectMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::netplay::P2PConnectMode::Direct,
            1 => crate::api::netplay::P2PConnectMode::Relay,
            _ => unreachable!("Invalid variant for P2PConnectMode: {}", inner),
        };
    }
}

impl SseDecode for crate::api::netplay::P2PJoinInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ok = <bool>::sse_decode(deserializer);
        let mut var_roomCode = <u32>::sse_decode(deserializer);
        let mut var_hostAddrs = <Vec<String>>::sse_decode(deserializer);
        let mut var_hostRoomCode = <u32>::sse_decode(deserializer);
        let mut var_hostQuicCertSha256Fingerprint = <Option<String>>::sse_decode(deserializer);
        let mut var_hostQuicServerName = <Option<String>>::sse_decode(deserializer);
        let mut var_fallbackRequired = <bool>::sse_decode(deserializer);
        let mut var_fallbackReason = <Option<String>>::sse_decode(deserializer);
        return crate::api::netplay::P2PJoinInfo {
            ok: var_ok,
            room_code: var_roomCode,
            host_addrs: var_hostAddrs,
            host_room_code: var_hostRoomCode,
            host_quic_cert_sha256_fingerprint: var_hostQuicCertSha256Fingerprint,
            host_quic_server_name: var_hostQuicServerName,
            fallback_required: var_fallbackRequired,
            fallback_reason: var_fallbackReason,
        };
    }
}

impl SseDecode for crate::api::palette::PaletteKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::palette::PaletteKind::NesdevNtsc,
            1 => crate::api::palette::PaletteKind::FbxCompositeDirect,
            2 => crate::api::palette::PaletteKind::SonyCxa2025AsUs,
            3 => crate::api::palette::PaletteKind::Pal2c07,
            4 => crate::api::palette::PaletteKind::RawLinear,
            _ => unreachable!("Invalid variant for PaletteKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::palette::PalettePresetInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_kind = <crate::api::palette::PaletteKind>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        return crate::api::palette::PalettePresetInfo {
            kind: var_kind,
            description: var_description,
        };
    }
}

impl SseDecode for crate::api::events::PaletteSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_palette = <Vec<u8>>::sse_decode(deserializer);
        let mut var_bgraPalette = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::events::PaletteSnapshot {
            palette: var_palette,
            bgra_palette: var_bgraPalette,
        };
    }
}

impl SseDecode for crate::senders::replay::ReplayEventNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::senders::replay::ReplayEventNotification::QuickSave,
            1 => crate::senders::replay::ReplayEventNotification::QuickLoad,
            _ => unreachable!("Invalid variant for ReplayEventNotification: {}", inner),
        };
    }
}

impl SseDecode for crate::api::events::RuntimeNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_kind = <crate::api::events::RuntimeNotificationKind>::sse_decode(deserializer);
        let mut var_error = <Option<String>>::sse_decode(deserializer);
        return crate::api::events::RuntimeNotification {
            kind: var_kind,
            error: var_error,
        };
    }
}

impl SseDecode for crate::api::events::RuntimeNotificationKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::events::RuntimeNotificationKind::AudioInitFailed,
            _ => unreachable!("Invalid variant for RuntimeNotificationKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::video::ScanlineOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_intensity = <f64>::sse_decode(deserializer);
        return crate::api::video::ScanlineOptions {
            intensity: var_intensity,
        };
    }
}

impl SseDecode for crate::api::server::ServerStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_running = <bool>::sse_decode(deserializer);
        let mut var_port = <u16>::sse_decode(deserializer);
        let mut var_clientCount = <u32>::sse_decode(deserializer);
        let mut var_bindAddress = <String>::sse_decode(deserializer);
        let mut var_quicEnabled = <bool>::sse_decode(deserializer);
        let mut var_quicBindAddress = <String>::sse_decode(deserializer);
        let mut var_quicCertSha256Fingerprint = <String>::sse_decode(deserializer);
        return crate::api::server::ServerStatus {
            running: var_running,
            port: var_port,
            client_count: var_clientCount,
            bind_address: var_bindAddress,
            quic_enabled: var_quicEnabled,
            quic_bind_address: var_quicBindAddress,
            quic_cert_sha256_fingerprint: var_quicCertSha256Fingerprint,
        };
    }
}

impl SseDecode for crate::api::events::SpriteInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_index = <u8>::sse_decode(deserializer);
        let mut var_x = <u8>::sse_decode(deserializer);
        let mut var_y = <u8>::sse_decode(deserializer);
        let mut var_tileIndex = <u8>::sse_decode(deserializer);
        let mut var_palette = <u8>::sse_decode(deserializer);
        let mut var_flipH = <bool>::sse_decode(deserializer);
        let mut var_flipV = <bool>::sse_decode(deserializer);
        let mut var_behindBg = <bool>::sse_decode(deserializer);
        let mut var_visible = <bool>::sse_decode(deserializer);
        return crate::api::events::SpriteInfo {
            index: var_index,
            x: var_x,
            y: var_y,
            tile_index: var_tileIndex,
            palette: var_palette,
            flip_h: var_flipH,
            flip_v: var_flipV,
            behind_bg: var_behindBg,
            visible: var_visible,
        };
    }
}

impl SseDecode for crate::api::events::SpriteSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sprites = <Vec<crate::api::events::SpriteInfo>>::sse_decode(deserializer);
        let mut var_thumbnailWidth = <u8>::sse_decode(deserializer);
        let mut var_thumbnailHeight = <u8>::sse_decode(deserializer);
        let mut var_largeSprites = <bool>::sse_decode(deserializer);
        let mut var_patternBase = <u16>::sse_decode(deserializer);
        let mut var_rgbaPalette = <Vec<u8>>::sse_decode(deserializer);
        return crate::api::events::SpriteSnapshot {
            sprites: var_sprites,
            thumbnail_width: var_thumbnailWidth,
            thumbnail_height: var_thumbnailHeight,
            large_sprites: var_largeSprites,
            pattern_base: var_patternBase,
            rgba_palette: var_rgbaPalette,
        };
    }
}

impl SseDecode for crate::api::events::TileSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_palette = <Vec<u8>>::sse_decode(deserializer);
        let mut var_rgbaPalette = <Vec<u8>>::sse_decode(deserializer);
        let mut var_selectedPalette = <u8>::sse_decode(deserializer);
        let mut var_width = <u16>::sse_decode(deserializer);
        let mut var_height = <u16>::sse_decode(deserializer);
        let mut var_source = <u8>::sse_decode(deserializer);
        let mut var_sourceSize = <u32>::sse_decode(deserializer);
        let mut var_startAddress = <u32>::sse_decode(deserializer);
        let mut var_columnCount = <u16>::sse_decode(deserializer);
        let mut var_rowCount = <u16>::sse_decode(deserializer);
        let mut var_layout = <u8>::sse_decode(deserializer);
        let mut var_background = <u8>::sse_decode(deserializer);
        let mut var_useGrayscalePalette = <bool>::sse_decode(deserializer);
        let mut var_bgPatternBase = <u16>::sse_decode(deserializer);
        let mut var_spritePatternBase = <u16>::sse_decode(deserializer);
        let mut var_largeSprites = <bool>::sse_decode(deserializer);
        return crate::api::events::TileSnapshot {
            palette: var_palette,
            rgba_palette: var_rgbaPalette,
            selected_palette: var_selectedPalette,
            width: var_width,
            height: var_height,
            source: var_source,
            source_size: var_sourceSize,
            start_address: var_startAddress,
            column_count: var_columnCount,
            row_count: var_rowCount,
            layout: var_layout,
            background: var_background,
            use_grayscale_palette: var_useGrayscalePalette,
            bg_pattern_base: var_bgPatternBase,
            sprite_pattern_base: var_spritePatternBase,
            large_sprites: var_largeSprites,
        };
    }
}

impl SseDecode for crate::api::events::TilemapMirroring {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::events::TilemapMirroring::Horizontal,
            1 => crate::api::events::TilemapMirroring::Vertical,
            2 => crate::api::events::TilemapMirroring::FourScreen,
            3 => crate::api::events::TilemapMirroring::SingleScreenLower,
            4 => crate::api::events::TilemapMirroring::SingleScreenUpper,
            5 => crate::api::events::TilemapMirroring::MapperControlled,
            _ => unreachable!("Invalid variant for TilemapMirroring: {}", inner),
        };
    }
}

impl SseDecode for crate::api::events::TilemapSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ciram = <Vec<u8>>::sse_decode(deserializer);
        let mut var_palette = <Vec<u8>>::sse_decode(deserializer);
        let mut var_chr = <Vec<u8>>::sse_decode(deserializer);
        let mut var_mirroring = <crate::api::events::TilemapMirroring>::sse_decode(deserializer);
        let mut var_bgPatternBase = <u16>::sse_decode(deserializer);
        let mut var_rgbaPalette = <Vec<u8>>::sse_decode(deserializer);
        let mut var_vramAddr = <u16>::sse_decode(deserializer);
        let mut var_tempAddr = <u16>::sse_decode(deserializer);
        let mut var_fineX = <u8>::sse_decode(deserializer);
        return crate::api::events::TilemapSnapshot {
            ciram: var_ciram,
            palette: var_palette,
            chr: var_chr,
            mirroring: var_mirroring,
            bg_pattern_base: var_bgPatternBase,
            rgba_palette: var_rgbaPalette,
            vram_addr: var_vramAddr,
            temp_addr: var_tempAddr,
            fine_x: var_fineX,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for crate::api::video::VideoFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::video::VideoFilter::None,
            1 => crate::api::video::VideoFilter::Prescale2x,
            2 => crate::api::video::VideoFilter::Prescale3x,
            3 => crate::api::video::VideoFilter::Prescale4x,
            4 => crate::api::video::VideoFilter::Hq2x,
            5 => crate::api::video::VideoFilter::Hq3x,
            6 => crate::api::video::VideoFilter::Hq4x,
            7 => crate::api::video::VideoFilter::Sai2x,
            8 => crate::api::video::VideoFilter::Super2xSai,
            9 => crate::api::video::VideoFilter::SuperEagle,
            10 => crate::api::video::VideoFilter::NtscComposite,
            11 => crate::api::video::VideoFilter::NtscSVideo,
            12 => crate::api::video::VideoFilter::NtscRgb,
            13 => crate::api::video::VideoFilter::NtscMonochrome,
            14 => crate::api::video::VideoFilter::LcdGrid,
            15 => crate::api::video::VideoFilter::Scanlines,
            16 => crate::api::video::VideoFilter::Xbrz2x,
            17 => crate::api::video::VideoFilter::Xbrz3x,
            18 => crate::api::video::VideoFilter::Xbrz4x,
            19 => crate::api::video::VideoFilter::Xbrz5x,
            20 => crate::api::video::VideoFilter::Xbrz6x,
            21 => crate::api::video::VideoFilter::NtscBisqwit2x,
            22 => crate::api::video::VideoFilter::NtscBisqwit4x,
            23 => crate::api::video::VideoFilter::NtscBisqwit8x,
            _ => unreachable!("Invalid variant for VideoFilter: {}", inner),
        };
    }
}

impl SseDecode for crate::api::video::VideoOutputInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_outputWidth = <u32>::sse_decode(deserializer);
        let mut var_outputHeight = <u32>::sse_decode(deserializer);
        return crate::api::video::VideoOutputInfo {
            output_width: var_outputWidth,
            output_height: var_outputHeight,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__events__aux_texture_ids_impl(port, ptr, rust_vec_len, data_len),
        2 => wire__crate__api__gamepad__bind_gamepad_impl(port, ptr, rust_vec_len, data_len),
        3 => wire__crate__api__events__debug_state_stream_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__events__emulation_status_stream_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        5 => wire__crate__api__gamepad__gamepad_actions_ffi_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        6 => wire__crate__api__gamepad__gamepad_poll_result_ffi_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        7 => wire__crate__api__gamepad__get_gamepad_mapping_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__gamepad__get_gamepad_pressed_buttons_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        9 => wire__crate__api__net_utils__get_local_addrs_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__net_utils__get_public_ip_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__load_rom__get_rom_hash_impl(port, ptr, rust_vec_len, data_len),
        12 => wire__crate__api__server__get_server_impl(port, ptr, rust_vec_len, data_len),
        14 => wire__crate__api__simple__init_app_impl(port, ptr, rust_vec_len, data_len),
        16 => wire__crate__api__gamepad__init_gamepad_impl(port, ptr, rust_vec_len, data_len),
        17 => wire__crate__api__pause__is_paused_impl(port, ptr, rust_vec_len, data_len),
        18 => wire__crate__api__video__lcd_grid_options_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        19 => wire__crate__api__gamepad__list_gamepads_impl(port, ptr, rust_vec_len, data_len),
        20 => wire__crate__api__load_rom__load_rom_impl(port, ptr, rust_vec_len, data_len),
        21 => {
            wire__crate__api__load_rom__load_rom_from_bytes_impl(port, ptr, rust_vec_len, data_len)
        }
        22 => wire__crate__api__emulation__load_state_impl(port, ptr, rust_vec_len, data_len),
        23 => wire__crate__api__emulation__load_state_from_memory_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        24 => wire__crate__api__emulation__load_tas_movie_impl(port, ptr, rust_vec_len, data_len),
        25 => wire__crate__api__netplay__netplay_connect_impl(port, ptr, rust_vec_len, data_len),
        26 => {
            wire__crate__api__netplay__netplay_connect_auto_impl(port, ptr, rust_vec_len, data_len)
        }
        27 => wire__crate__api__netplay__netplay_connect_auto_pinned_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        28 => {
            wire__crate__api__netplay__netplay_connect_quic_impl(port, ptr, rust_vec_len, data_len)
        }
        29 => wire__crate__api__netplay__netplay_connect_quic_pinned_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        30 => {
            wire__crate__api__netplay__netplay_create_room_impl(port, ptr, rust_vec_len, data_len)
        }
        31 => wire__crate__api__netplay__netplay_disconnect_impl(port, ptr, rust_vec_len, data_len),
        32 => wire__crate__api__netplay__netplay_game_event_stream_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        33 => {
            wire__crate__api__netplay__netplay_is_connected_impl(port, ptr, rust_vec_len, data_len)
        }
        34 => wire__crate__api__netplay__netplay_join_room_impl(port, ptr, rust_vec_len, data_len),
        35 => wire__crate__api__netplay__netplay_p2p_connect_join_auto_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        36 => wire__crate__api__netplay__netplay_p2p_create_room_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        37 => wire__crate__api__netplay__netplay_p2p_host_create_and_watch_fallback_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        38 => wire__crate__api__netplay__netplay_p2p_host_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        39 => {
            wire__crate__api__netplay__netplay_p2p_join_room_impl(port, ptr, rust_vec_len, data_len)
        }
        40 => wire__crate__api__netplay__netplay_p2p_request_fallback_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        41 => {
            wire__crate__api__netplay__netplay_provide_state_impl(port, ptr, rust_vec_len, data_len)
        }
        42 => wire__crate__api__netplay__netplay_request_fallback_relay_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        43 => {
            wire__crate__api__netplay__netplay_request_state_impl(port, ptr, rust_vec_len, data_len)
        }
        44 => wire__crate__api__netplay__netplay_send_pause_impl(port, ptr, rust_vec_len, data_len),
        45 => wire__crate__api__netplay__netplay_send_reset_impl(port, ptr, rust_vec_len, data_len),
        46 => wire__crate__api__netplay__netplay_send_rom_impl(port, ptr, rust_vec_len, data_len),
        47 => wire__crate__api__netplay__netplay_send_rom_loaded_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        48 => {
            wire__crate__api__netplay__netplay_status_stream_impl(port, ptr, rust_vec_len, data_len)
        }
        49 => {
            wire__crate__api__netplay__netplay_switch_role_impl(port, ptr, rust_vec_len, data_len)
        }
        50 => wire__crate__api__server__netserver_get_port_impl(port, ptr, rust_vec_len, data_len),
        51 => {
            wire__crate__api__server__netserver_is_running_impl(port, ptr, rust_vec_len, data_len)
        }
        52 => wire__crate__api__server__netserver_start_impl(port, ptr, rust_vec_len, data_len),
        53 => wire__crate__api__server__netserver_status_stream_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        54 => wire__crate__api__server__netserver_stop_impl(port, ptr, rust_vec_len, data_len),
        55 => wire__crate__api__video__ntsc_bisqwit_options_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        56 => wire__crate__api__video__ntsc_options_default_impl(port, ptr, rust_vec_len, data_len),
        57 => wire__crate__api__palette__palette_presets_impl(port, ptr, rust_vec_len, data_len),
        58 => {
            wire__crate__api__events__palette_state_stream_impl(port, ptr, rust_vec_len, data_len)
        }
        59 => wire__crate__api__gamepad__poll_gamepads_impl(port, ptr, rust_vec_len, data_len),
        60 => wire__crate__api__load_rom__power_off_console_impl(port, ptr, rust_vec_len, data_len),
        61 => {
            wire__crate__api__load_rom__power_reset_console_impl(port, ptr, rust_vec_len, data_len)
        }
        62 => wire__crate__api__events__replay_event_stream_impl(port, ptr, rust_vec_len, data_len),
        63 => wire__crate__api__load_rom__reset_console_impl(port, ptr, rust_vec_len, data_len),
        64 => wire__crate__api__gamepad__rumble_gamepad_impl(port, ptr, rust_vec_len, data_len),
        65 => {
            wire__crate__api__events__runtime_notifications_impl(port, ptr, rust_vec_len, data_len)
        }
        66 => wire__crate__api__emulation__save_state_impl(port, ptr, rust_vec_len, data_len),
        67 => wire__crate__api__emulation__save_state_to_memory_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        68 => wire__crate__api__video__scanline_options_default_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        69 => wire__crate__api__emulation__set_fast_forward_speed_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        70 => {
            wire__crate__api__emulation__set_fast_forwarding_impl(port, ptr, rust_vec_len, data_len)
        }
        71 => {
            wire__crate__api__gamepad__set_gamepad_mapping_impl(port, ptr, rust_vec_len, data_len)
        }
        72 => wire__crate__api__emulation__set_integer_fps_mode_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        73 => wire__crate__api__video__set_lcd_grid_options_impl(port, ptr, rust_vec_len, data_len),
        74 => wire__crate__api__video__set_ntsc_bisqwit_options_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        75 => wire__crate__api__video__set_ntsc_options_impl(port, ptr, rust_vec_len, data_len),
        76 => wire__crate__api__input__set_pad_mask_impl(port, ptr, rust_vec_len, data_len),
        77 => wire__crate__api__events__set_palette_capture_frame_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        78 => wire__crate__api__events__set_palette_capture_scanline_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        79 => wire__crate__api__events__set_palette_capture_vblank_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        80 => {
            wire__crate__api__palette__set_palette_pal_data_impl(port, ptr, rust_vec_len, data_len)
        }
        81 => wire__crate__api__palette__set_palette_preset_impl(port, ptr, rust_vec_len, data_len),
        82 => wire__crate__api__pause__set_paused_impl(port, ptr, rust_vec_len, data_len),
        83 => {
            wire__crate__api__emulation__set_rewind_config_impl(port, ptr, rust_vec_len, data_len)
        }
        84 => wire__crate__api__emulation__set_rewind_speed_impl(port, ptr, rust_vec_len, data_len),
        85 => wire__crate__api__emulation__set_rewinding_impl(port, ptr, rust_vec_len, data_len),
        86 => wire__crate__api__video__set_scanline_options_impl(port, ptr, rust_vec_len, data_len),
        87 => wire__crate__api__video__set_shader_enabled_impl(port, ptr, rust_vec_len, data_len),
        88 => {
            wire__crate__api__video__set_shader_preset_path_impl(port, ptr, rust_vec_len, data_len)
        }
        89 => wire__crate__api__events__set_sprite_capture_frame_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        90 => wire__crate__api__events__set_sprite_capture_scanline_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        91 => wire__crate__api__events__set_sprite_capture_vblank_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        92 => wire__crate__api__events__set_tile_viewer_background_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        93 => wire__crate__api__events__set_tile_viewer_capture_frame_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        94 => wire__crate__api__events__set_tile_viewer_capture_scanline_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        95 => wire__crate__api__events__set_tile_viewer_capture_vblank_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        96 => wire__crate__api__events__set_tile_viewer_display_mode_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        97 => {
            wire__crate__api__events__set_tile_viewer_layout_impl(port, ptr, rust_vec_len, data_len)
        }
        98 => wire__crate__api__events__set_tile_viewer_palette_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        99 => {
            wire__crate__api__events__set_tile_viewer_size_impl(port, ptr, rust_vec_len, data_len)
        }
        100 => {
            wire__crate__api__events__set_tile_viewer_source_impl(port, ptr, rust_vec_len, data_len)
        }
        101 => wire__crate__api__events__set_tile_viewer_start_address_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        102 => wire__crate__api__events__set_tilemap_capture_frame_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        103 => wire__crate__api__events__set_tilemap_capture_scanline_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        104 => wire__crate__api__events__set_tilemap_capture_vblank_start_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        105 => wire__crate__api__events__set_tilemap_display_mode_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        106 => wire__crate__api__input__set_turbo_frames_per_toggle_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        107 => wire__crate__api__input__set_turbo_mask_impl(port, ptr, rust_vec_len, data_len),
        108 => wire__crate__api__input__set_turbo_timing_impl(port, ptr, rust_vec_len, data_len),
        109 => wire__crate__api__video__set_video_filter_impl(port, ptr, rust_vec_len, data_len),
        110 => wire__crate__api__gamepad__shutdown_gamepad_impl(port, ptr, rust_vec_len, data_len),
        111 => {
            wire__crate__api__events__sprite_state_stream_impl(port, ptr, rust_vec_len, data_len)
        }
        112 => {
            wire__crate__api__load_rom__start_nes_runtime_impl(port, ptr, rust_vec_len, data_len)
        }
        113 => wire__crate__api__events__subscribe_tilemap_texture_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        114 => wire__crate__api__events__tile_state_stream_impl(port, ptr, rust_vec_len, data_len),
        115 => {
            wire__crate__api__events__tilemap_state_stream_impl(port, ptr, rust_vec_len, data_len)
        }
        116 => wire__crate__api__pause__toggle_pause_impl(port, ptr, rust_vec_len, data_len),
        117 => {
            wire__crate__api__net_utils__try_upnp_mapping_impl(port, ptr, rust_vec_len, data_len)
        }
        118 => wire__crate__api__events__unsubscribe_debug_state_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        119 => wire__crate__api__events__unsubscribe_palette_state_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        120 => wire__crate__api__events__unsubscribe_sprite_state_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        121 => {
            wire__crate__api__events__unsubscribe_tile_state_impl(port, ptr, rust_vec_len, data_len)
        }
        122 => wire__crate__api__events__unsubscribe_tilemap_texture_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        13 => wire__crate__api__simple__greet_impl(ptr, rust_vec_len, data_len),
        15 => wire__crate__api__simple__init_app_paths_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::AuxTextureIds {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.tilemap.into_into_dart().into_dart(),
            self.tile.into_into_dart().into_dart(),
            self.sprite.into_into_dart().into_dart(),
            self.sprite_screen.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::AuxTextureIds
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::AuxTextureIds>
    for crate::api::events::AuxTextureIds
{
    fn into_into_dart(self) -> crate::api::events::AuxTextureIds {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::DebugStateNotification {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.cpu_pc.into_into_dart().into_dart(),
            self.cpu_a.into_into_dart().into_dart(),
            self.cpu_x.into_into_dart().into_dart(),
            self.cpu_y.into_into_dart().into_dart(),
            self.cpu_sp.into_into_dart().into_dart(),
            self.cpu_status.into_into_dart().into_dart(),
            self.cpu_cycle.into_into_dart().into_dart(),
            self.ppu_scanline.into_into_dart().into_dart(),
            self.ppu_cycle.into_into_dart().into_dart(),
            self.ppu_frame.into_into_dart().into_dart(),
            self.ppu_ctrl.into_into_dart().into_dart(),
            self.ppu_mask.into_into_dart().into_dart(),
            self.ppu_status.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::DebugStateNotification
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::DebugStateNotification>
    for crate::api::events::DebugStateNotification
{
    fn into_into_dart(self) -> crate::api::events::DebugStateNotification {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::EmulationStatusNotification {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.paused.into_into_dart().into_dart(),
            self.rewinding.into_into_dart().into_dart(),
            self.fast_forwarding.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::EmulationStatusNotification
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::EmulationStatusNotification>
    for crate::api::events::EmulationStatusNotification
{
    fn into_into_dart(self) -> crate::api::events::EmulationStatusNotification {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::gamepad::GamepadActionsFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.rewind.into_into_dart().into_dart(),
            self.fast_forward.into_into_dart().into_dart(),
            self.save_state.into_into_dart().into_dart(),
            self.load_state.into_into_dart().into_dart(),
            self.pause.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::gamepad::GamepadActionsFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::gamepad::GamepadActionsFfi>
    for crate::api::gamepad::GamepadActionsFfi
{
    fn into_into_dart(self) -> crate::api::gamepad::GamepadActionsFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::gamepad::GamepadButtonFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::South => 0.into_dart(),
            Self::East => 1.into_dart(),
            Self::North => 2.into_dart(),
            Self::West => 3.into_dart(),
            Self::C => 4.into_dart(),
            Self::Z => 5.into_dart(),
            Self::LeftTrigger => 6.into_dart(),
            Self::LeftTrigger2 => 7.into_dart(),
            Self::RightTrigger => 8.into_dart(),
            Self::RightTrigger2 => 9.into_dart(),
            Self::Select => 10.into_dart(),
            Self::Start => 11.into_dart(),
            Self::Mode => 12.into_dart(),
            Self::LeftThumb => 13.into_dart(),
            Self::RightThumb => 14.into_dart(),
            Self::DPadUp => 15.into_dart(),
            Self::DPadDown => 16.into_dart(),
            Self::DPadLeft => 17.into_dart(),
            Self::DPadRight => 18.into_dart(),
            Self::Unknown => 19.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::gamepad::GamepadButtonFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::gamepad::GamepadButtonFfi>
    for crate::api::gamepad::GamepadButtonFfi
{
    fn into_into_dart(self) -> crate::api::gamepad::GamepadButtonFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::gamepad::GamepadInfoFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.connected.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::gamepad::GamepadInfoFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::gamepad::GamepadInfoFfi>
    for crate::api::gamepad::GamepadInfoFfi
{
    fn into_into_dart(self) -> crate::api::gamepad::GamepadInfoFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::gamepad::GamepadMappingFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.a.into_into_dart().into_dart(),
            self.b.into_into_dart().into_dart(),
            self.select.into_into_dart().into_dart(),
            self.start.into_into_dart().into_dart(),
            self.up.into_into_dart().into_dart(),
            self.down.into_into_dart().into_dart(),
            self.left.into_into_dart().into_dart(),
            self.right.into_into_dart().into_dart(),
            self.turbo_a.into_into_dart().into_dart(),
            self.turbo_b.into_into_dart().into_dart(),
            self.rewind.into_into_dart().into_dart(),
            self.fast_forward.into_into_dart().into_dart(),
            self.save_state.into_into_dart().into_dart(),
            self.load_state.into_into_dart().into_dart(),
            self.pause.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::gamepad::GamepadMappingFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::gamepad::GamepadMappingFfi>
    for crate::api::gamepad::GamepadMappingFfi
{
    fn into_into_dart(self) -> crate::api::gamepad::GamepadMappingFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::gamepad::GamepadPollResultFfi {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.pad_masks.into_into_dart().into_dart(),
            self.turbo_masks.into_into_dart().into_dart(),
            self.actions.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::gamepad::GamepadPollResultFfi
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::gamepad::GamepadPollResultFfi>
    for crate::api::gamepad::GamepadPollResultFfi
{
    fn into_into_dart(self) -> crate::api::gamepad::GamepadPollResultFfi {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::video::LcdGridOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.strength.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::video::LcdGridOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::video::LcdGridOptions>
    for crate::api::video::LcdGridOptions
{
    fn into_into_dart(self) -> crate::api::video::LcdGridOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::NetplayGameEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::netplay::NetplayGameEvent::LoadRom { data } => {
                [0.into_dart(), data.into_into_dart().into_dart()].into_dart()
            }
            crate::api::netplay::NetplayGameEvent::StartGame => [1.into_dart()].into_dart(),
            crate::api::netplay::NetplayGameEvent::PauseSync { paused } => {
                [2.into_dart(), paused.into_into_dart().into_dart()].into_dart()
            }
            crate::api::netplay::NetplayGameEvent::ResetSync { kind } => {
                [3.into_dart(), kind.into_into_dart().into_dart()].into_dart()
            }
            crate::api::netplay::NetplayGameEvent::SyncState { frame, data } => [
                4.into_dart(),
                frame.into_into_dart().into_dart(),
                data.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::api::netplay::NetplayGameEvent::PlayerLeft { player_index } => {
                [5.into_dart(), player_index.into_into_dart().into_dart()].into_dart()
            }
            crate::api::netplay::NetplayGameEvent::Error { error_code } => {
                [6.into_dart(), error_code.into_into_dart().into_dart()].into_dart()
            }
            crate::api::netplay::NetplayGameEvent::FallbackToRelay {
                relay_addr,
                relay_room_code,
                reason,
            } => [
                7.into_dart(),
                relay_addr.into_into_dart().into_dart(),
                relay_room_code.into_into_dart().into_dart(),
                reason.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::NetplayGameEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::NetplayGameEvent>
    for crate::api::netplay::NetplayGameEvent
{
    fn into_into_dart(self) -> crate::api::netplay::NetplayGameEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::NetplayPlayer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.client_id.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.player_index.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::NetplayPlayer
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::NetplayPlayer>
    for crate::api::netplay::NetplayPlayer
{
    fn into_into_dart(self) -> crate::api::netplay::NetplayPlayer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::NetplayState {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Disconnected => 0.into_dart(),
            Self::Connecting => 1.into_dart(),
            Self::Connected => 2.into_dart(),
            Self::InRoom => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::NetplayState
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::NetplayState>
    for crate::api::netplay::NetplayState
{
    fn into_into_dart(self) -> crate::api::netplay::NetplayState {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::NetplayStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.state.into_into_dart().into_dart(),
            self.transport.into_into_dart().into_dart(),
            self.tcp_fallback_from_quic.into_into_dart().into_dart(),
            self.client_id.into_into_dart().into_dart(),
            self.room_id.into_into_dart().into_dart(),
            self.player_index.into_into_dart().into_dart(),
            self.players.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::NetplayStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::NetplayStatus>
    for crate::api::netplay::NetplayStatus
{
    fn into_into_dart(self) -> crate::api::netplay::NetplayStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::NetplayTransport {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Unknown => 0.into_dart(),
            Self::Tcp => 1.into_dart(),
            Self::Quic => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::NetplayTransport
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::NetplayTransport>
    for crate::api::netplay::NetplayTransport
{
    fn into_into_dart(self) -> crate::api::netplay::NetplayTransport {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::video::NtscBisqwitOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.brightness.into_into_dart().into_dart(),
            self.contrast.into_into_dart().into_dart(),
            self.hue.into_into_dart().into_dart(),
            self.saturation.into_into_dart().into_dart(),
            self.y_filter_length.into_into_dart().into_dart(),
            self.i_filter_length.into_into_dart().into_dart(),
            self.q_filter_length.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::video::NtscBisqwitOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::video::NtscBisqwitOptions>
    for crate::api::video::NtscBisqwitOptions
{
    fn into_into_dart(self) -> crate::api::video::NtscBisqwitOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::video::NtscOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.hue.into_into_dart().into_dart(),
            self.saturation.into_into_dart().into_dart(),
            self.contrast.into_into_dart().into_dart(),
            self.brightness.into_into_dart().into_dart(),
            self.sharpness.into_into_dart().into_dart(),
            self.gamma.into_into_dart().into_dart(),
            self.resolution.into_into_dart().into_dart(),
            self.artifacts.into_into_dart().into_dart(),
            self.fringing.into_into_dart().into_dart(),
            self.bleed.into_into_dart().into_dart(),
            self.merge_fields.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::video::NtscOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::video::NtscOptions>
    for crate::api::video::NtscOptions
{
    fn into_into_dart(self) -> crate::api::video::NtscOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::P2PConnectMode {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Direct => 0.into_dart(),
            Self::Relay => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::P2PConnectMode
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::P2PConnectMode>
    for crate::api::netplay::P2PConnectMode
{
    fn into_into_dart(self) -> crate::api::netplay::P2PConnectMode {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::netplay::P2PJoinInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ok.into_into_dart().into_dart(),
            self.room_code.into_into_dart().into_dart(),
            self.host_addrs.into_into_dart().into_dart(),
            self.host_room_code.into_into_dart().into_dart(),
            self.host_quic_cert_sha256_fingerprint
                .into_into_dart()
                .into_dart(),
            self.host_quic_server_name.into_into_dart().into_dart(),
            self.fallback_required.into_into_dart().into_dart(),
            self.fallback_reason.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::netplay::P2PJoinInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::netplay::P2PJoinInfo>
    for crate::api::netplay::P2PJoinInfo
{
    fn into_into_dart(self) -> crate::api::netplay::P2PJoinInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::palette::PaletteKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::NesdevNtsc => 0.into_dart(),
            Self::FbxCompositeDirect => 1.into_dart(),
            Self::SonyCxa2025AsUs => 2.into_dart(),
            Self::Pal2c07 => 3.into_dart(),
            Self::RawLinear => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::palette::PaletteKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::palette::PaletteKind>
    for crate::api::palette::PaletteKind
{
    fn into_into_dart(self) -> crate::api::palette::PaletteKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::palette::PalettePresetInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.kind.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::palette::PalettePresetInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::palette::PalettePresetInfo>
    for crate::api::palette::PalettePresetInfo
{
    fn into_into_dart(self) -> crate::api::palette::PalettePresetInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::PaletteSnapshot {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.palette.into_into_dart().into_dart(),
            self.bgra_palette.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::PaletteSnapshot
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::PaletteSnapshot>
    for crate::api::events::PaletteSnapshot
{
    fn into_into_dart(self) -> crate::api::events::PaletteSnapshot {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::senders::replay::ReplayEventNotification {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::QuickSave => 0.into_dart(),
            Self::QuickLoad => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::senders::replay::ReplayEventNotification
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::senders::replay::ReplayEventNotification>
    for crate::senders::replay::ReplayEventNotification
{
    fn into_into_dart(self) -> crate::senders::replay::ReplayEventNotification {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::RuntimeNotification {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.kind.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::RuntimeNotification
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::RuntimeNotification>
    for crate::api::events::RuntimeNotification
{
    fn into_into_dart(self) -> crate::api::events::RuntimeNotification {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::RuntimeNotificationKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::AudioInitFailed => 0.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::RuntimeNotificationKind
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::RuntimeNotificationKind>
    for crate::api::events::RuntimeNotificationKind
{
    fn into_into_dart(self) -> crate::api::events::RuntimeNotificationKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::video::ScanlineOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.intensity.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::video::ScanlineOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::video::ScanlineOptions>
    for crate::api::video::ScanlineOptions
{
    fn into_into_dart(self) -> crate::api::video::ScanlineOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::server::ServerStatus {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.running.into_into_dart().into_dart(),
            self.port.into_into_dart().into_dart(),
            self.client_count.into_into_dart().into_dart(),
            self.bind_address.into_into_dart().into_dart(),
            self.quic_enabled.into_into_dart().into_dart(),
            self.quic_bind_address.into_into_dart().into_dart(),
            self.quic_cert_sha256_fingerprint
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::server::ServerStatus
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::server::ServerStatus>
    for crate::api::server::ServerStatus
{
    fn into_into_dart(self) -> crate::api::server::ServerStatus {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::SpriteInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.index.into_into_dart().into_dart(),
            self.x.into_into_dart().into_dart(),
            self.y.into_into_dart().into_dart(),
            self.tile_index.into_into_dart().into_dart(),
            self.palette.into_into_dart().into_dart(),
            self.flip_h.into_into_dart().into_dart(),
            self.flip_v.into_into_dart().into_dart(),
            self.behind_bg.into_into_dart().into_dart(),
            self.visible.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::SpriteInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::SpriteInfo>
    for crate::api::events::SpriteInfo
{
    fn into_into_dart(self) -> crate::api::events::SpriteInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::SpriteSnapshot {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sprites.into_into_dart().into_dart(),
            self.thumbnail_width.into_into_dart().into_dart(),
            self.thumbnail_height.into_into_dart().into_dart(),
            self.large_sprites.into_into_dart().into_dart(),
            self.pattern_base.into_into_dart().into_dart(),
            self.rgba_palette.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::SpriteSnapshot
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::SpriteSnapshot>
    for crate::api::events::SpriteSnapshot
{
    fn into_into_dart(self) -> crate::api::events::SpriteSnapshot {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::TileSnapshot {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.palette.into_into_dart().into_dart(),
            self.rgba_palette.into_into_dart().into_dart(),
            self.selected_palette.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
            self.height.into_into_dart().into_dart(),
            self.source.into_into_dart().into_dart(),
            self.source_size.into_into_dart().into_dart(),
            self.start_address.into_into_dart().into_dart(),
            self.column_count.into_into_dart().into_dart(),
            self.row_count.into_into_dart().into_dart(),
            self.layout.into_into_dart().into_dart(),
            self.background.into_into_dart().into_dart(),
            self.use_grayscale_palette.into_into_dart().into_dart(),
            self.bg_pattern_base.into_into_dart().into_dart(),
            self.sprite_pattern_base.into_into_dart().into_dart(),
            self.large_sprites.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::TileSnapshot
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::TileSnapshot>
    for crate::api::events::TileSnapshot
{
    fn into_into_dart(self) -> crate::api::events::TileSnapshot {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::TilemapMirroring {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Horizontal => 0.into_dart(),
            Self::Vertical => 1.into_dart(),
            Self::FourScreen => 2.into_dart(),
            Self::SingleScreenLower => 3.into_dart(),
            Self::SingleScreenUpper => 4.into_dart(),
            Self::MapperControlled => 5.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::TilemapMirroring
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::TilemapMirroring>
    for crate::api::events::TilemapMirroring
{
    fn into_into_dart(self) -> crate::api::events::TilemapMirroring {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::events::TilemapSnapshot {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ciram.into_into_dart().into_dart(),
            self.palette.into_into_dart().into_dart(),
            self.chr.into_into_dart().into_dart(),
            self.mirroring.into_into_dart().into_dart(),
            self.bg_pattern_base.into_into_dart().into_dart(),
            self.rgba_palette.into_into_dart().into_dart(),
            self.vram_addr.into_into_dart().into_dart(),
            self.temp_addr.into_into_dart().into_dart(),
            self.fine_x.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::events::TilemapSnapshot
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::events::TilemapSnapshot>
    for crate::api::events::TilemapSnapshot
{
    fn into_into_dart(self) -> crate::api::events::TilemapSnapshot {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::video::VideoFilter {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::None => 0.into_dart(),
            Self::Prescale2x => 1.into_dart(),
            Self::Prescale3x => 2.into_dart(),
            Self::Prescale4x => 3.into_dart(),
            Self::Hq2x => 4.into_dart(),
            Self::Hq3x => 5.into_dart(),
            Self::Hq4x => 6.into_dart(),
            Self::Sai2x => 7.into_dart(),
            Self::Super2xSai => 8.into_dart(),
            Self::SuperEagle => 9.into_dart(),
            Self::NtscComposite => 10.into_dart(),
            Self::NtscSVideo => 11.into_dart(),
            Self::NtscRgb => 12.into_dart(),
            Self::NtscMonochrome => 13.into_dart(),
            Self::LcdGrid => 14.into_dart(),
            Self::Scanlines => 15.into_dart(),
            Self::Xbrz2x => 16.into_dart(),
            Self::Xbrz3x => 17.into_dart(),
            Self::Xbrz4x => 18.into_dart(),
            Self::Xbrz5x => 19.into_dart(),
            Self::Xbrz6x => 20.into_dart(),
            Self::NtscBisqwit2x => 21.into_dart(),
            Self::NtscBisqwit4x => 22.into_dart(),
            Self::NtscBisqwit8x => 23.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::video::VideoFilter
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::video::VideoFilter>
    for crate::api::video::VideoFilter
{
    fn into_into_dart(self) -> crate::api::video::VideoFilter {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::video::VideoOutputInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.output_width.into_into_dart().into_dart(),
            self.output_height.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::video::VideoOutputInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::video::VideoOutputInfo>
    for crate::api::video::VideoOutputInfo
{
    fn into_into_dart(self) -> crate::api::video::VideoOutputInfo {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode
    for StreamSink<
        crate::api::events::DebugStateNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::events::EmulationStatusNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::netplay::NetplayGameEvent,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::netplay::NetplayStatus, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::events::PaletteSnapshot,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::senders::replay::ReplayEventNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::events::RuntimeNotification,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::server::ServerStatus, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::events::SpriteSnapshot, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<crate::api::events::TileSnapshot, flutter_rust_bridge::for_generated::SseCodec>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode
    for StreamSink<
        crate::api::events::TilemapSnapshot,
        flutter_rust_bridge::for_generated::SseCodec,
    >
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("")
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::events::AuxTextureIds {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.tilemap, serializer);
        <u32>::sse_encode(self.tile, serializer);
        <u32>::sse_encode(self.sprite, serializer);
        <u32>::sse_encode(self.sprite_screen, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::events::DebugStateNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u16>::sse_encode(self.cpu_pc, serializer);
        <u8>::sse_encode(self.cpu_a, serializer);
        <u8>::sse_encode(self.cpu_x, serializer);
        <u8>::sse_encode(self.cpu_y, serializer);
        <u8>::sse_encode(self.cpu_sp, serializer);
        <u8>::sse_encode(self.cpu_status, serializer);
        <u64>::sse_encode(self.cpu_cycle, serializer);
        <i16>::sse_encode(self.ppu_scanline, serializer);
        <u16>::sse_encode(self.ppu_cycle, serializer);
        <u32>::sse_encode(self.ppu_frame, serializer);
        <u8>::sse_encode(self.ppu_ctrl, serializer);
        <u8>::sse_encode(self.ppu_mask, serializer);
        <u8>::sse_encode(self.ppu_status, serializer);
    }
}

impl SseEncode for crate::api::events::EmulationStatusNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.paused, serializer);
        <bool>::sse_encode(self.rewinding, serializer);
        <bool>::sse_encode(self.fast_forwarding, serializer);
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::gamepad::GamepadActionsFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.rewind, serializer);
        <bool>::sse_encode(self.fast_forward, serializer);
        <bool>::sse_encode(self.save_state, serializer);
        <bool>::sse_encode(self.load_state, serializer);
        <bool>::sse_encode(self.pause, serializer);
    }
}

impl SseEncode for crate::api::gamepad::GamepadButtonFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::gamepad::GamepadButtonFfi::South => 0,
                crate::api::gamepad::GamepadButtonFfi::East => 1,
                crate::api::gamepad::GamepadButtonFfi::North => 2,
                crate::api::gamepad::GamepadButtonFfi::West => 3,
                crate::api::gamepad::GamepadButtonFfi::C => 4,
                crate::api::gamepad::GamepadButtonFfi::Z => 5,
                crate::api::gamepad::GamepadButtonFfi::LeftTrigger => 6,
                crate::api::gamepad::GamepadButtonFfi::LeftTrigger2 => 7,
                crate::api::gamepad::GamepadButtonFfi::RightTrigger => 8,
                crate::api::gamepad::GamepadButtonFfi::RightTrigger2 => 9,
                crate::api::gamepad::GamepadButtonFfi::Select => 10,
                crate::api::gamepad::GamepadButtonFfi::Start => 11,
                crate::api::gamepad::GamepadButtonFfi::Mode => 12,
                crate::api::gamepad::GamepadButtonFfi::LeftThumb => 13,
                crate::api::gamepad::GamepadButtonFfi::RightThumb => 14,
                crate::api::gamepad::GamepadButtonFfi::DPadUp => 15,
                crate::api::gamepad::GamepadButtonFfi::DPadDown => 16,
                crate::api::gamepad::GamepadButtonFfi::DPadLeft => 17,
                crate::api::gamepad::GamepadButtonFfi::DPadRight => 18,
                crate::api::gamepad::GamepadButtonFfi::Unknown => 19,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::gamepad::GamepadInfoFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.name, serializer);
        <bool>::sse_encode(self.connected, serializer);
        <Option<u8>>::sse_encode(self.port, serializer);
    }
}

impl SseEncode for crate::api::gamepad::GamepadMappingFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.a, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.b, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.select, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.start, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.up, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.down, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.left, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.right, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.turbo_a, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.turbo_b, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.rewind, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.fast_forward, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.save_state, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.load_state, serializer);
        <Option<crate::api::gamepad::GamepadButtonFfi>>::sse_encode(self.pause, serializer);
    }
}

impl SseEncode for crate::api::gamepad::GamepadPollResultFfi {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.pad_masks, serializer);
        <Vec<u8>>::sse_encode(self.turbo_masks, serializer);
        <crate::api::gamepad::GamepadActionsFfi>::sse_encode(self.actions, serializer);
    }
}

impl SseEncode for i16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::video::LcdGridOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.strength, serializer);
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::gamepad::GamepadButtonFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::gamepad::GamepadButtonFfi>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::gamepad::GamepadInfoFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::gamepad::GamepadInfoFfi>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::netplay::NetplayPlayer> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::netplay::NetplayPlayer>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::palette::PalettePresetInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::palette::PalettePresetInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::events::SpriteInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::events::SpriteInfo>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::netplay::NetplayGameEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::netplay::NetplayGameEvent::LoadRom { data } => {
                <i32>::sse_encode(0, serializer);
                <Vec<u8>>::sse_encode(data, serializer);
            }
            crate::api::netplay::NetplayGameEvent::StartGame => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::netplay::NetplayGameEvent::PauseSync { paused } => {
                <i32>::sse_encode(2, serializer);
                <bool>::sse_encode(paused, serializer);
            }
            crate::api::netplay::NetplayGameEvent::ResetSync { kind } => {
                <i32>::sse_encode(3, serializer);
                <u8>::sse_encode(kind, serializer);
            }
            crate::api::netplay::NetplayGameEvent::SyncState { frame, data } => {
                <i32>::sse_encode(4, serializer);
                <u32>::sse_encode(frame, serializer);
                <Vec<u8>>::sse_encode(data, serializer);
            }
            crate::api::netplay::NetplayGameEvent::PlayerLeft { player_index } => {
                <i32>::sse_encode(5, serializer);
                <u8>::sse_encode(player_index, serializer);
            }
            crate::api::netplay::NetplayGameEvent::Error { error_code } => {
                <i32>::sse_encode(6, serializer);
                <u16>::sse_encode(error_code, serializer);
            }
            crate::api::netplay::NetplayGameEvent::FallbackToRelay {
                relay_addr,
                relay_room_code,
                reason,
            } => {
                <i32>::sse_encode(7, serializer);
                <String>::sse_encode(relay_addr, serializer);
                <u32>::sse_encode(relay_room_code, serializer);
                <String>::sse_encode(reason, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::netplay::NetplayPlayer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.client_id, serializer);
        <String>::sse_encode(self.name, serializer);
        <u8>::sse_encode(self.player_index, serializer);
    }
}

impl SseEncode for crate::api::netplay::NetplayState {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::netplay::NetplayState::Disconnected => 0,
                crate::api::netplay::NetplayState::Connecting => 1,
                crate::api::netplay::NetplayState::Connected => 2,
                crate::api::netplay::NetplayState::InRoom => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::netplay::NetplayStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::netplay::NetplayState>::sse_encode(self.state, serializer);
        <crate::api::netplay::NetplayTransport>::sse_encode(self.transport, serializer);
        <bool>::sse_encode(self.tcp_fallback_from_quic, serializer);
        <u32>::sse_encode(self.client_id, serializer);
        <u32>::sse_encode(self.room_id, serializer);
        <u8>::sse_encode(self.player_index, serializer);
        <Vec<crate::api::netplay::NetplayPlayer>>::sse_encode(self.players, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::api::netplay::NetplayTransport {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::netplay::NetplayTransport::Unknown => 0,
                crate::api::netplay::NetplayTransport::Tcp => 1,
                crate::api::netplay::NetplayTransport::Quic => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::video::NtscBisqwitOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.brightness, serializer);
        <f64>::sse_encode(self.contrast, serializer);
        <f64>::sse_encode(self.hue, serializer);
        <f64>::sse_encode(self.saturation, serializer);
        <f64>::sse_encode(self.y_filter_length, serializer);
        <f64>::sse_encode(self.i_filter_length, serializer);
        <f64>::sse_encode(self.q_filter_length, serializer);
    }
}

impl SseEncode for crate::api::video::NtscOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.hue, serializer);
        <f64>::sse_encode(self.saturation, serializer);
        <f64>::sse_encode(self.contrast, serializer);
        <f64>::sse_encode(self.brightness, serializer);
        <f64>::sse_encode(self.sharpness, serializer);
        <f64>::sse_encode(self.gamma, serializer);
        <f64>::sse_encode(self.resolution, serializer);
        <f64>::sse_encode(self.artifacts, serializer);
        <f64>::sse_encode(self.fringing, serializer);
        <f64>::sse_encode(self.bleed, serializer);
        <bool>::sse_encode(self.merge_fields, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::gamepad::GamepadButtonFfi> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::gamepad::GamepadButtonFfi>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u8>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u8>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::netplay::P2PConnectMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::netplay::P2PConnectMode::Direct => 0,
                crate::api::netplay::P2PConnectMode::Relay => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::netplay::P2PJoinInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.ok, serializer);
        <u32>::sse_encode(self.room_code, serializer);
        <Vec<String>>::sse_encode(self.host_addrs, serializer);
        <u32>::sse_encode(self.host_room_code, serializer);
        <Option<String>>::sse_encode(self.host_quic_cert_sha256_fingerprint, serializer);
        <Option<String>>::sse_encode(self.host_quic_server_name, serializer);
        <bool>::sse_encode(self.fallback_required, serializer);
        <Option<String>>::sse_encode(self.fallback_reason, serializer);
    }
}

impl SseEncode for crate::api::palette::PaletteKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::palette::PaletteKind::NesdevNtsc => 0,
                crate::api::palette::PaletteKind::FbxCompositeDirect => 1,
                crate::api::palette::PaletteKind::SonyCxa2025AsUs => 2,
                crate::api::palette::PaletteKind::Pal2c07 => 3,
                crate::api::palette::PaletteKind::RawLinear => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::palette::PalettePresetInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::palette::PaletteKind>::sse_encode(self.kind, serializer);
        <String>::sse_encode(self.description, serializer);
    }
}

impl SseEncode for crate::api::events::PaletteSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.palette, serializer);
        <Vec<u8>>::sse_encode(self.bgra_palette, serializer);
    }
}

impl SseEncode for crate::senders::replay::ReplayEventNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::senders::replay::ReplayEventNotification::QuickSave => 0,
                crate::senders::replay::ReplayEventNotification::QuickLoad => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::events::RuntimeNotification {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::events::RuntimeNotificationKind>::sse_encode(self.kind, serializer);
        <Option<String>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::api::events::RuntimeNotificationKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::events::RuntimeNotificationKind::AudioInitFailed => 0,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::video::ScanlineOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.intensity, serializer);
    }
}

impl SseEncode for crate::api::server::ServerStatus {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.running, serializer);
        <u16>::sse_encode(self.port, serializer);
        <u32>::sse_encode(self.client_count, serializer);
        <String>::sse_encode(self.bind_address, serializer);
        <bool>::sse_encode(self.quic_enabled, serializer);
        <String>::sse_encode(self.quic_bind_address, serializer);
        <String>::sse_encode(self.quic_cert_sha256_fingerprint, serializer);
    }
}

impl SseEncode for crate::api::events::SpriteInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u8>::sse_encode(self.index, serializer);
        <u8>::sse_encode(self.x, serializer);
        <u8>::sse_encode(self.y, serializer);
        <u8>::sse_encode(self.tile_index, serializer);
        <u8>::sse_encode(self.palette, serializer);
        <bool>::sse_encode(self.flip_h, serializer);
        <bool>::sse_encode(self.flip_v, serializer);
        <bool>::sse_encode(self.behind_bg, serializer);
        <bool>::sse_encode(self.visible, serializer);
    }
}

impl SseEncode for crate::api::events::SpriteSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::api::events::SpriteInfo>>::sse_encode(self.sprites, serializer);
        <u8>::sse_encode(self.thumbnail_width, serializer);
        <u8>::sse_encode(self.thumbnail_height, serializer);
        <bool>::sse_encode(self.large_sprites, serializer);
        <u16>::sse_encode(self.pattern_base, serializer);
        <Vec<u8>>::sse_encode(self.rgba_palette, serializer);
    }
}

impl SseEncode for crate::api::events::TileSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.palette, serializer);
        <Vec<u8>>::sse_encode(self.rgba_palette, serializer);
        <u8>::sse_encode(self.selected_palette, serializer);
        <u16>::sse_encode(self.width, serializer);
        <u16>::sse_encode(self.height, serializer);
        <u8>::sse_encode(self.source, serializer);
        <u32>::sse_encode(self.source_size, serializer);
        <u32>::sse_encode(self.start_address, serializer);
        <u16>::sse_encode(self.column_count, serializer);
        <u16>::sse_encode(self.row_count, serializer);
        <u8>::sse_encode(self.layout, serializer);
        <u8>::sse_encode(self.background, serializer);
        <bool>::sse_encode(self.use_grayscale_palette, serializer);
        <u16>::sse_encode(self.bg_pattern_base, serializer);
        <u16>::sse_encode(self.sprite_pattern_base, serializer);
        <bool>::sse_encode(self.large_sprites, serializer);
    }
}

impl SseEncode for crate::api::events::TilemapMirroring {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::events::TilemapMirroring::Horizontal => 0,
                crate::api::events::TilemapMirroring::Vertical => 1,
                crate::api::events::TilemapMirroring::FourScreen => 2,
                crate::api::events::TilemapMirroring::SingleScreenLower => 3,
                crate::api::events::TilemapMirroring::SingleScreenUpper => 4,
                crate::api::events::TilemapMirroring::MapperControlled => 5,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::events::TilemapSnapshot {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.ciram, serializer);
        <Vec<u8>>::sse_encode(self.palette, serializer);
        <Vec<u8>>::sse_encode(self.chr, serializer);
        <crate::api::events::TilemapMirroring>::sse_encode(self.mirroring, serializer);
        <u16>::sse_encode(self.bg_pattern_base, serializer);
        <Vec<u8>>::sse_encode(self.rgba_palette, serializer);
        <u16>::sse_encode(self.vram_addr, serializer);
        <u16>::sse_encode(self.temp_addr, serializer);
        <u8>::sse_encode(self.fine_x, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::video::VideoFilter {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::video::VideoFilter::None => 0,
                crate::api::video::VideoFilter::Prescale2x => 1,
                crate::api::video::VideoFilter::Prescale3x => 2,
                crate::api::video::VideoFilter::Prescale4x => 3,
                crate::api::video::VideoFilter::Hq2x => 4,
                crate::api::video::VideoFilter::Hq3x => 5,
                crate::api::video::VideoFilter::Hq4x => 6,
                crate::api::video::VideoFilter::Sai2x => 7,
                crate::api::video::VideoFilter::Super2xSai => 8,
                crate::api::video::VideoFilter::SuperEagle => 9,
                crate::api::video::VideoFilter::NtscComposite => 10,
                crate::api::video::VideoFilter::NtscSVideo => 11,
                crate::api::video::VideoFilter::NtscRgb => 12,
                crate::api::video::VideoFilter::NtscMonochrome => 13,
                crate::api::video::VideoFilter::LcdGrid => 14,
                crate::api::video::VideoFilter::Scanlines => 15,
                crate::api::video::VideoFilter::Xbrz2x => 16,
                crate::api::video::VideoFilter::Xbrz3x => 17,
                crate::api::video::VideoFilter::Xbrz4x => 18,
                crate::api::video::VideoFilter::Xbrz5x => 19,
                crate::api::video::VideoFilter::Xbrz6x => 20,
                crate::api::video::VideoFilter::NtscBisqwit2x => 21,
                crate::api::video::VideoFilter::NtscBisqwit4x => 22,
                crate::api::video::VideoFilter::NtscBisqwit8x => 23,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::video::VideoOutputInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u32>::sse_encode(self.output_width, serializer);
        <u32>::sse_encode(self.output_height, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{Lifetimeable, Lockable, transform_result_dco};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{Lifetimeable, Lockable, transform_result_dco};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();
}
#[cfg(target_family = "wasm")]
pub use web::*;
