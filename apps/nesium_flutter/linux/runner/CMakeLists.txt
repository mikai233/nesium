cmake_minimum_required(VERSION 3.10)
project(runner LANGUAGES CXX)

# ==============================================================================
# 1. Helper Functions
# ==============================================================================

# Helper to find where the Flutter bundle is located.
function(nesium_get_bundle_dir out_var)
  if(DEFINED CMAKE_RUNTIME_OUTPUT_DIRECTORY)
    set(_bundle_dir "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}")
  else()
    set(_bundle_dir "${CMAKE_BINARY_DIR}/bundle")
  endif()
  get_filename_component(_bundle_dir_abs "${_bundle_dir}" ABSOLUTE)
  set(${out_var} "${_bundle_dir_abs}" PARENT_SCOPE)
endfunction()

# ==============================================================================
# 2. Path & Profile Configuration
# ==============================================================================

# Define the root path relative to this file
# linux/runner -> linux -> apps -> root
set(PROJECT_ROOT "${CMAKE_CURRENT_SOURCE_DIR}/../../../../")
set(CRATE_DIR "${PROJECT_ROOT}/crates/nesium-flutter")

# Logic:
# - Flutter Release -> Rust 'release-dist'
# - Flutter Debug/Profile -> Rust 'release' (Ensures performance during dev)
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    set(RUST_PROFILE "release-dist")
    set(CARGO_ARGS "--profile" "release-dist")
    # By default, custom profiles output to target/<profile_name>
    set(TARGET_DIR "release-dist") 
else()
    set(RUST_PROFILE "release")
    set(CARGO_ARGS "--release")
    set(TARGET_DIR "release")
endif()

# Define where the .so file is generated by Cargo
# NOTE: Rust always normalizes dashes to underscores in filenames (nesium-flutter -> libnesium_flutter.so)
set(RUST_LIB_FILENAME "libnesium_flutter.so")
set(RUST_LIB_SRC "${PROJECT_ROOT}/target/${TARGET_DIR}/${RUST_LIB_FILENAME}")

# ==============================================================================
# 3. Build Rust Target
# ==============================================================================

# Ninja needs to know which file is produced; otherwise it will error before running Cargo.
add_custom_command(
    OUTPUT "${RUST_LIB_SRC}"
    COMMAND cargo build --manifest-path "${CRATE_DIR}/Cargo.toml" --lib ${CARGO_ARGS}
    WORKING_DIRECTORY "${PROJECT_ROOT}"
    COMMENT "Building Rust library (${RUST_PROFILE})..."
    VERBATIM
)

add_custom_target(cargo_build ALL
    DEPENDS "${RUST_LIB_SRC}"
)

# ==============================================================================
# 4. Flutter Runner Configuration
# ==============================================================================

add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "nesium/nesium_channels.cc"
  "nesium/nesium_texture.cc"
)

# Ensure Cargo runs before linking C++
add_dependencies(${BINARY_NAME} cargo_build)

# ==============================================================================
# 5. Linkage
# ==============================================================================

# Define an imported target for the Rust library.
# We point directly to the file in target/release/ or target/debug/
add_library(rust_lib SHARED IMPORTED GLOBAL)
set_target_properties(rust_lib PROPERTIES IMPORTED_LOCATION "${RUST_LIB_SRC}")

# Link the imported target
target_link_libraries(${BINARY_NAME} PRIVATE rust_lib)

# Standard Flutter dependencies
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# PREVENT LINKER OPTIMIZATION
# This is crucial for FFI. It forces the linker to include the library.
target_link_options(${BINARY_NAME} PRIVATE "-Wl,--no-as-needed")

# ==============================================================================
# 6. Runtime Path (RPATH)
# ==============================================================================
# Tell the Linux loader to look for the .so in the 'lib' folder next to the binary.
set_target_properties(${BINARY_NAME} PROPERTIES
  BUILD_WITH_INSTALL_RPATH TRUE
  INSTALL_RPATH "$ORIGIN/lib"
  BUILD_RPATH   "$ORIGIN/lib"
)

# ==============================================================================
# 7. Post-Build Copy (For 'flutter run' / Debug)
# ==============================================================================
# This copies the .so file to build/.../bundle/lib/ so the app can find it when running locally.
add_custom_command(TARGET ${BINARY_NAME} POST_BUILD
    # 1. Ensure 'lib' directory exists
    COMMAND ${CMAKE_COMMAND} -E make_directory "$<TARGET_FILE_DIR:${BINARY_NAME}>/lib"
    
    # 2. Copy the .so file
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
        "${RUST_LIB_SRC}"
        "$<TARGET_FILE_DIR:${BINARY_NAME}>/lib/${RUST_LIB_FILENAME}"
        
    COMMENT "Copying ${RUST_LIB_FILENAME} to bundle/lib..."
)

# ==============================================================================
# 8. Install Rules (For 'flutter build linux' / Release)
# ==============================================================================
# This ensures the .so file is included in the final distribution package.
install(FILES "${RUST_LIB_SRC}"
    DESTINATION "lib"
    COMPONENT Runtime
)

apply_standard_settings(${BINARY_NAME})