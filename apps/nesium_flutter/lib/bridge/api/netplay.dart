// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'netplay.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `lock_unpoison`, `netplay_disconnect_inner`, `notify_status`, `resolve_addr`, `signaling_connect_and_handshake`, `signaling_request`, `start_netplay_session_with_client`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `NetplayManager`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `get_manager`

/// Set the netplay synchronization mode.
///
/// Host only, should be called before game starts.
Future<void> netplaySetSyncMode({required SyncMode mode}) =>
    RustLib.instance.api.crateApiNetplayNetplaySetSyncMode(mode: mode);

/// Get the current netplay synchronization mode.
Future<SyncMode> netplayGetSyncMode() =>
    RustLib.instance.api.crateApiNetplayNetplayGetSyncMode();

/// Connect to netplay server and perform handshake.
Future<void> netplayConnect({
  required String serverAddr,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnect(
  serverAddr: serverAddr,
  playerName: playerName,
);

/// Connect to netplay server and perform handshake (QUIC preferred, TCP fallback).
Future<void> netplayConnectAuto({
  required String serverAddr,
  required String serverName,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectAuto(
  serverAddr: serverAddr,
  serverName: serverName,
  playerName: playerName,
);

/// Connect to netplay server and perform handshake (QUIC pinned SHA-256 fingerprint preferred, TCP fallback).
Future<void> netplayConnectAutoPinned({
  required String serverAddr,
  required String serverName,
  required String pinnedSha256Fingerprint,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectAutoPinned(
  serverAddr: serverAddr,
  serverName: serverName,
  pinnedSha256Fingerprint: pinnedSha256Fingerprint,
  playerName: playerName,
);

/// Connect to netplay server over QUIC and perform handshake.
Future<void> netplayConnectQuic({
  required String serverAddr,
  required String serverName,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectQuic(
  serverAddr: serverAddr,
  serverName: serverName,
  playerName: playerName,
);

/// Connect to netplay server over QUIC (pinned SHA-256 fingerprint) and perform handshake.
Future<void> netplayConnectQuicPinned({
  required String serverAddr,
  required String serverName,
  required String pinnedSha256Fingerprint,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectQuicPinned(
  serverAddr: serverAddr,
  serverName: serverName,
  pinnedSha256Fingerprint: pinnedSha256Fingerprint,
  playerName: playerName,
);

/// Create a new netplay room.
Future<void> netplayCreateRoom() =>
    RustLib.instance.api.crateApiNetplayNetplayCreateRoom();

/// Join an existing netplay room by code.
Future<void> netplayJoinRoom({
  required int roomId,
  required int desiredRole,
  required bool hasRom,
}) => RustLib.instance.api.crateApiNetplayNetplayJoinRoom(
  roomId: roomId,
  desiredRole: desiredRole,
  hasRom: hasRom,
);

/// Query room occupancy/state by join code (before joining).
Future<NetplayRoomInfo> netplayQueryRoom({required int roomId}) =>
    RustLib.instance.api.crateApiNetplayNetplayQueryRoom(roomId: roomId);

/// Switch player role (1P, 2P, Spectator).
Future<void> netplaySwitchRole({required int role}) =>
    RustLib.instance.api.crateApiNetplayNetplaySwitchRole(role: role);

/// Host-only: ask the current server to instruct all connected clients to reconnect to relay mode.
Future<void> netplayRequestFallbackRelay({
  required String relayAddr,
  required int relayRoomId,
  required String reason,
}) => RustLib.instance.api.crateApiNetplayNetplayRequestFallbackRelay(
  relayAddr: relayAddr,
  relayRoomId: relayRoomId,
  reason: reason,
);

/// Disconnect from netplay server.
Future<void> netplayDisconnect() =>
    RustLib.instance.api.crateApiNetplayNetplayDisconnect();

Future<bool> netplayIsConnected() =>
    RustLib.instance.api.crateApiNetplayNetplayIsConnected();

/// Subscribe to netplay status updates.
Stream<NetplayStatus> netplayStatusStream() =>
    RustLib.instance.api.crateApiNetplayNetplayStatusStream();

/// Subscribe to Game events (LoadRom, StartGame).
Stream<NetplayGameEvent> netplayGameEventStream() =>
    RustLib.instance.api.crateApiNetplayNetplayGameEventStream();

/// Create a P2P signaling room on `nesium-netd` and publish direct-connect info for the host.
///
/// Returns the room ID that joiners should use on the signaling server (and for relay fallback).
Future<int> netplayP2PCreateRoom({
  required String signalingAddr,
  required List<String> hostAddrs,
  required int hostRoomId,
  String? hostQuicCertSha256Fingerprint,
  String? hostQuicServerName,
  required String name,
}) => RustLib.instance.api.crateApiNetplayNetplayP2PCreateRoom(
  signalingAddr: signalingAddr,
  hostAddrs: hostAddrs,
  hostRoomId: hostRoomId,
  hostQuicCertSha256Fingerprint: hostQuicCertSha256Fingerprint,
  hostQuicServerName: hostQuicServerName,
  name: name,
);

/// Start the full P2P host workflow:
/// 1. Start embedded server (OS-assigned port).
/// 2. Discover local IPs and Public IP.
/// 3. Create P2P room on signaling server.
/// 4. Watch for fallback notices.
///
/// Returns the P2P room ID.
Future<int> netplayP2PHostStart({
  required String signalingAddr,
  required String relayAddr,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayP2PHostStart(
  signalingAddr: signalingAddr,
  relayAddr: relayAddr,
  playerName: playerName,
);

/// Host flow:
/// - Creates a P2P signaling room on `signaling_addr` (netd).
/// - Spawns a background watcher for `P2PFallbackNotice`.
/// - On fallback notice: tells direct clients to reconnect to `relay_addr`, stops the embedded
///   server (best-effort), and connects this device to relay mode as a client.
///
/// UI requirement:
/// - `relay_addr` is user-provided (manual input), e.g. `example.com:15000` or `1.2.3.4:15000`.
Future<int> netplayP2PHostCreateAndWatchFallback({
  required String signalingAddr,
  required String relayAddr,
  required List<String> hostAddrs,
  required int hostRoomId,
  String? hostQuicCertSha256Fingerprint,
  String? hostQuicServerName,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayP2PHostCreateAndWatchFallback(
  signalingAddr: signalingAddr,
  relayAddr: relayAddr,
  hostAddrs: hostAddrs,
  hostRoomId: hostRoomId,
  hostQuicCertSha256Fingerprint: hostQuicCertSha256Fingerprint,
  hostQuicServerName: hostQuicServerName,
  playerName: playerName,
);

/// Fetch host direct-connect info for a given P2P signaling room.
Future<P2PJoinInfo> netplayP2PJoinRoom({
  required String signalingAddr,
  required int roomId,
  required String name,
}) => RustLib.instance.api.crateApiNetplayNetplayP2PJoinRoom(
  signalingAddr: signalingAddr,
  roomId: roomId,
  name: name,
);

/// Join a P2P room via signaling, then try direct-connect to the host server.
///
/// If direct-connect fails, requests relay fallback on the signaling server and connects to the
/// user-provided relay server address (netd authoritative mode).
///
/// Notes:
/// - `relay_addr` must point to a running `nesium-netd` instance.
/// - `room_id` is the P2P signaling room ID, and is reused as the relay room ID in fallback mode.
Future<P2PConnectMode> netplayP2PConnectJoinAuto({
  required String signalingAddr,
  required String relayAddr,
  required int roomId,
  required String playerName,
  required int desiredRole,
  required bool hasRom,
}) => RustLib.instance.api.crateApiNetplayNetplayP2PConnectJoinAuto(
  signalingAddr: signalingAddr,
  relayAddr: relayAddr,
  roomId: roomId,
  playerName: playerName,
  desiredRole: desiredRole,
  hasRom: hasRom,
);

/// Request switching a P2P signaling room into relay fallback mode (netd authoritative C/S).
Future<void> netplayP2PRequestFallback({
  required String signalingAddr,
  required int roomId,
  required String reason,
  required String name,
}) => RustLib.instance.api.crateApiNetplayNetplayP2PRequestFallback(
  signalingAddr: signalingAddr,
  roomId: roomId,
  reason: reason,
  name: name,
);

/// Send ROM to other players.
Future<void> netplaySendRom({required List<int> data}) =>
    RustLib.instance.api.crateApiNetplayNetplaySendRom(data: data);

/// Confirm ROM loaded to server.
Future<void> netplaySendRomLoaded() =>
    RustLib.instance.api.crateApiNetplayNetplaySendRomLoaded();

/// Send pause state to other players.
Future<void> netplaySendPause({required bool paused}) =>
    RustLib.instance.api.crateApiNetplayNetplaySendPause(paused: paused);

/// Send reset to other players.
Future<void> netplaySendReset({required int kind}) =>
    RustLib.instance.api.crateApiNetplayNetplaySendReset(kind: kind);

/// Request current game state from server (for reconnection).
Future<void> netplayRequestState() =>
    RustLib.instance.api.crateApiNetplayNetplayRequestState();

/// Provide current game state to server for caching.
Future<void> netplayProvideState({
  required int frame,
  required List<int> data,
}) => RustLib.instance.api.crateApiNetplayNetplayProvideState(
  frame: frame,
  data: data,
);

@freezed
sealed class NetplayGameEvent with _$NetplayGameEvent {
  const NetplayGameEvent._();

  const factory NetplayGameEvent.loadRom({required Uint8List data}) =
      NetplayGameEvent_LoadRom;
  const factory NetplayGameEvent.startGame() = NetplayGameEvent_StartGame;
  const factory NetplayGameEvent.pauseSync({required bool paused}) =
      NetplayGameEvent_PauseSync;
  const factory NetplayGameEvent.resetSync({required int kind}) =
      NetplayGameEvent_ResetSync;
  const factory NetplayGameEvent.syncState({
    required int frame,
    required Uint8List data,
  }) = NetplayGameEvent_SyncState;
  const factory NetplayGameEvent.playerLeft({required int playerIndex}) =
      NetplayGameEvent_PlayerLeft;

  /// Server error (e.g., room not found, permission denied)
  const factory NetplayGameEvent.error({required int errorCode}) =
      NetplayGameEvent_Error;

  /// Server instructed this client to reconnect to relay mode.
  const factory NetplayGameEvent.fallbackToRelay({
    required String relayAddr,
    required int relayRoomId,
    required String reason,
  }) = NetplayGameEvent_FallbackToRelay;
}

class NetplayPlayer {
  final int clientId;
  final String name;
  final int playerIndex;

  const NetplayPlayer({
    required this.clientId,
    required this.name,
    required this.playerIndex,
  });

  @override
  int get hashCode => clientId.hashCode ^ name.hashCode ^ playerIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetplayPlayer &&
          runtimeType == other.runtimeType &&
          clientId == other.clientId &&
          name == other.name &&
          playerIndex == other.playerIndex;
}

/// Room snapshot for pre-join UI (which slots are occupied, etc.).
class NetplayRoomInfo {
  final bool ok;
  final int roomId;
  final bool started;
  final SyncMode syncMode;

  /// Bitmask: bit N set if slot N is occupied (0..3).
  final int occupiedMask;

  const NetplayRoomInfo({
    required this.ok,
    required this.roomId,
    required this.started,
    required this.syncMode,
    required this.occupiedMask,
  });

  @override
  int get hashCode =>
      ok.hashCode ^
      roomId.hashCode ^
      started.hashCode ^
      syncMode.hashCode ^
      occupiedMask.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetplayRoomInfo &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          roomId == other.roomId &&
          started == other.started &&
          syncMode == other.syncMode &&
          occupiedMask == other.occupiedMask;
}

/// Netplay connection state.
enum NetplayState { disconnected, connecting, connected, inRoom }

/// Netplay status snapshot streamed to Flutter.
class NetplayStatus {
  final NetplayState state;
  final NetplayTransport transport;

  /// True if QUIC connection failed and we fell back to TCP (only for Auto connect modes).
  final bool tcpFallbackFromQuic;
  final int clientId;
  final int roomId;

  /// Player index: 0, 1, or `SPECTATOR_PLAYER_INDEX` for spectator
  final int playerIndex;
  final List<NetplayPlayer> players;

  /// Current synchronization mode for the room
  final SyncMode syncMode;
  final String? error;

  const NetplayStatus({
    required this.state,
    required this.transport,
    required this.tcpFallbackFromQuic,
    required this.clientId,
    required this.roomId,
    required this.playerIndex,
    required this.players,
    required this.syncMode,
    this.error,
  });

  @override
  int get hashCode =>
      state.hashCode ^
      transport.hashCode ^
      tcpFallbackFromQuic.hashCode ^
      clientId.hashCode ^
      roomId.hashCode ^
      playerIndex.hashCode ^
      players.hashCode ^
      syncMode.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetplayStatus &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          transport == other.transport &&
          tcpFallbackFromQuic == other.tcpFallbackFromQuic &&
          clientId == other.clientId &&
          roomId == other.roomId &&
          playerIndex == other.playerIndex &&
          players == other.players &&
          syncMode == other.syncMode &&
          error == other.error;
}

/// Actual transport used by the current netplay session.
enum NetplayTransport { unknown, tcp, quic }

enum P2PConnectMode { direct, relay }

class P2PJoinInfo {
  final bool ok;
  final int roomId;
  final List<String> hostAddrs;
  final int hostRoomId;
  final String? hostQuicCertSha256Fingerprint;
  final String? hostQuicServerName;
  final bool fallbackRequired;
  final String? fallbackReason;

  const P2PJoinInfo({
    required this.ok,
    required this.roomId,
    required this.hostAddrs,
    required this.hostRoomId,
    this.hostQuicCertSha256Fingerprint,
    this.hostQuicServerName,
    required this.fallbackRequired,
    this.fallbackReason,
  });

  @override
  int get hashCode =>
      ok.hashCode ^
      roomId.hashCode ^
      hostAddrs.hashCode ^
      hostRoomId.hashCode ^
      hostQuicCertSha256Fingerprint.hashCode ^
      hostQuicServerName.hashCode ^
      fallbackRequired.hashCode ^
      fallbackReason.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is P2PJoinInfo &&
          runtimeType == other.runtimeType &&
          ok == other.ok &&
          roomId == other.roomId &&
          hostAddrs == other.hostAddrs &&
          hostRoomId == other.hostRoomId &&
          hostQuicCertSha256Fingerprint ==
              other.hostQuicCertSha256Fingerprint &&
          hostQuicServerName == other.hostQuicServerName &&
          fallbackRequired == other.fallbackRequired &&
          fallbackReason == other.fallbackReason;
}

/// Netplay synchronization mode.
enum SyncMode {
  /// Wait for all players' confirmed inputs before advancing each frame.
  /// Best for low-latency networks (LAN, same region).
  lockstep,

  /// Predict remote inputs and rollback/resimulate on misprediction.
  /// Best for high-latency networks (cross-region, internet).
  rollback;

  static Future<SyncMode> default_() =>
      RustLib.instance.api.crateApiNetplaySyncModeDefault();
}
