// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'netplay.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `lock_unpoison`, `notify_status`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `NetplayManager`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `get_manager`

/// Connect to netplay server and perform handshake.
Future<void> netplayConnect({
  required String serverAddr,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnect(
  serverAddr: serverAddr,
  playerName: playerName,
);

/// Connect to netplay server and perform handshake (QUIC preferred, TCP fallback).
Future<void> netplayConnectAuto({
  required String serverAddr,
  required String serverName,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectAuto(
  serverAddr: serverAddr,
  serverName: serverName,
  playerName: playerName,
);

/// Connect to netplay server and perform handshake (QUIC pinned SHA-256 fingerprint preferred, TCP fallback).
Future<void> netplayConnectAutoPinned({
  required String serverAddr,
  required String serverName,
  required String pinnedSha256Fingerprint,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectAutoPinned(
  serverAddr: serverAddr,
  serverName: serverName,
  pinnedSha256Fingerprint: pinnedSha256Fingerprint,
  playerName: playerName,
);

/// Connect to netplay server over QUIC and perform handshake.
Future<void> netplayConnectQuic({
  required String serverAddr,
  required String serverName,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectQuic(
  serverAddr: serverAddr,
  serverName: serverName,
  playerName: playerName,
);

/// Connect to netplay server over QUIC (pinned SHA-256 fingerprint) and perform handshake.
Future<void> netplayConnectQuicPinned({
  required String serverAddr,
  required String serverName,
  required String pinnedSha256Fingerprint,
  required String playerName,
}) => RustLib.instance.api.crateApiNetplayNetplayConnectQuicPinned(
  serverAddr: serverAddr,
  serverName: serverName,
  pinnedSha256Fingerprint: pinnedSha256Fingerprint,
  playerName: playerName,
);

/// Create a new netplay room.
Future<void> netplayCreateRoom() =>
    RustLib.instance.api.crateApiNetplayNetplayCreateRoom();

/// Join an existing netplay room by code.
Future<void> netplayJoinRoom({required int roomCode}) =>
    RustLib.instance.api.crateApiNetplayNetplayJoinRoom(roomCode: roomCode);

/// Switch player role (1P, 2P, Spectator).
Future<void> netplaySwitchRole({required int role}) =>
    RustLib.instance.api.crateApiNetplayNetplaySwitchRole(role: role);

/// Disconnect from netplay server.
Future<void> netplayDisconnect() =>
    RustLib.instance.api.crateApiNetplayNetplayDisconnect();

Future<bool> netplayIsConnected() =>
    RustLib.instance.api.crateApiNetplayNetplayIsConnected();

/// Subscribe to netplay status updates.
Stream<NetplayStatus> netplayStatusStream() =>
    RustLib.instance.api.crateApiNetplayNetplayStatusStream();

/// Subscribe to Game events (LoadRom, StartGame).
Stream<NetplayGameEvent> netplayGameEventStream() =>
    RustLib.instance.api.crateApiNetplayNetplayGameEventStream();

/// Send ROM to other players.
Future<void> netplaySendRom({required List<int> data}) =>
    RustLib.instance.api.crateApiNetplayNetplaySendRom(data: data);

/// Confirm ROM loaded to server.
Future<void> netplaySendRomLoaded() =>
    RustLib.instance.api.crateApiNetplayNetplaySendRomLoaded();

/// Send pause state to other players.
Future<void> netplaySendPause({required bool paused}) =>
    RustLib.instance.api.crateApiNetplayNetplaySendPause(paused: paused);

/// Send reset to other players.
Future<void> netplaySendReset({required int kind}) =>
    RustLib.instance.api.crateApiNetplayNetplaySendReset(kind: kind);

/// Request current game state from server (for reconnection).
Future<void> netplayRequestState() =>
    RustLib.instance.api.crateApiNetplayNetplayRequestState();

/// Provide current game state to server for caching.
Future<void> netplayProvideState({
  required int frame,
  required List<int> data,
}) => RustLib.instance.api.crateApiNetplayNetplayProvideState(
  frame: frame,
  data: data,
);

@freezed
sealed class NetplayGameEvent with _$NetplayGameEvent {
  const NetplayGameEvent._();

  const factory NetplayGameEvent.loadRom({required Uint8List data}) =
      NetplayGameEvent_LoadRom;
  const factory NetplayGameEvent.startGame() = NetplayGameEvent_StartGame;
  const factory NetplayGameEvent.pauseSync({required bool paused}) =
      NetplayGameEvent_PauseSync;
  const factory NetplayGameEvent.resetSync({required int kind}) =
      NetplayGameEvent_ResetSync;
  const factory NetplayGameEvent.syncState({
    required int frame,
    required Uint8List data,
  }) = NetplayGameEvent_SyncState;
  const factory NetplayGameEvent.playerLeft({required int playerIndex}) =
      NetplayGameEvent_PlayerLeft;

  /// Server error (e.g., room not found, permission denied)
  const factory NetplayGameEvent.error({required int errorCode}) =
      NetplayGameEvent_Error;
}

class NetplayPlayer {
  final int clientId;
  final String name;
  final int playerIndex;

  const NetplayPlayer({
    required this.clientId,
    required this.name,
    required this.playerIndex,
  });

  @override
  int get hashCode => clientId.hashCode ^ name.hashCode ^ playerIndex.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetplayPlayer &&
          runtimeType == other.runtimeType &&
          clientId == other.clientId &&
          name == other.name &&
          playerIndex == other.playerIndex;
}

/// Netplay connection state.
enum NetplayState { disconnected, connecting, connected, inRoom }

/// Netplay status snapshot streamed to Flutter.
class NetplayStatus {
  final NetplayState state;
  final NetplayTransport transport;

  /// True if QUIC connection failed and we fell back to TCP (only for Auto connect modes).
  final bool tcpFallbackFromQuic;
  final int clientId;
  final int roomId;

  /// Player index: 0, 1, or `SPECTATOR_PLAYER_INDEX` for spectator
  final int playerIndex;
  final List<NetplayPlayer> players;
  final String? error;

  const NetplayStatus({
    required this.state,
    required this.transport,
    required this.tcpFallbackFromQuic,
    required this.clientId,
    required this.roomId,
    required this.playerIndex,
    required this.players,
    this.error,
  });

  @override
  int get hashCode =>
      state.hashCode ^
      transport.hashCode ^
      tcpFallbackFromQuic.hashCode ^
      clientId.hashCode ^
      roomId.hashCode ^
      playerIndex.hashCode ^
      players.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NetplayStatus &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          transport == other.transport &&
          tcpFallbackFromQuic == other.tcpFallbackFromQuic &&
          clientId == other.clientId &&
          roomId == other.roomId &&
          playerIndex == other.playerIndex &&
          players == other.players &&
          error == other.error;
}

/// Actual transport used by the current netplay session.
enum NetplayTransport { unknown, tcp, quic }
