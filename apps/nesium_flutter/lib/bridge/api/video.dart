// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `apply_video_filter`, `current_filter`, `is_ntsc_bisqwit_filter`, `is_ntsc_filter`, `lcd_grid_options`, `ntsc_bisqwit_options`, `ntsc_options`, `output_size`, `scale_factor`, `scanline_options`, `set_current_filter`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

Stream<ShaderParameters> shaderParametersStream() =>
    RustLib.instance.api.crateApiVideoShaderParametersStream();

Future<VideoOutputInfo> setVideoFilter({required VideoFilter filter}) =>
    RustLib.instance.api.crateApiVideoSetVideoFilter(filter: filter);

Future<void> setNtscOptions({required NtscOptions options}) =>
    RustLib.instance.api.crateApiVideoSetNtscOptions(options: options);

Future<void> setLcdGridOptions({required LcdGridOptions options}) =>
    RustLib.instance.api.crateApiVideoSetLcdGridOptions(options: options);

Future<void> setScanlineOptions({required ScanlineOptions options}) =>
    RustLib.instance.api.crateApiVideoSetScanlineOptions(options: options);

Future<void> setNtscBisqwitOptions({required NtscBisqwitOptions options}) =>
    RustLib.instance.api.crateApiVideoSetNtscBisqwitOptions(options: options);

Future<void> setShaderEnabled({required bool enabled}) =>
    RustLib.instance.api.crateApiVideoSetShaderEnabled(enabled: enabled);

Future<void> setShaderPresetPath({String? path}) =>
    RustLib.instance.api.crateApiVideoSetShaderPresetPath(path: path);

Future<ShaderParameters> getShaderParameters() =>
    RustLib.instance.api.crateApiVideoGetShaderParameters();

Future<void> setShaderParameter({
  required String name,
  required double value,
}) => RustLib.instance.api.crateApiVideoSetShaderParameter(
  name: name,
  value: value,
);

class LcdGridOptions {
  /// Strength in `0.0..=1.0` (0 = off, 1 = strongest / default).
  final double strength;

  const LcdGridOptions({required this.strength});

  static Future<LcdGridOptions> default_() =>
      RustLib.instance.api.crateApiVideoLcdGridOptionsDefault();

  @override
  int get hashCode => strength.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LcdGridOptions &&
          runtimeType == other.runtimeType &&
          strength == other.strength;
}

class NtscBisqwitOptions {
  final double brightness;
  final double contrast;
  final double hue;
  final double saturation;
  final double yFilterLength;
  final double iFilterLength;
  final double qFilterLength;

  const NtscBisqwitOptions({
    required this.brightness,
    required this.contrast,
    required this.hue,
    required this.saturation,
    required this.yFilterLength,
    required this.iFilterLength,
    required this.qFilterLength,
  });

  static Future<NtscBisqwitOptions> default_() =>
      RustLib.instance.api.crateApiVideoNtscBisqwitOptionsDefault();

  @override
  int get hashCode =>
      brightness.hashCode ^
      contrast.hashCode ^
      hue.hashCode ^
      saturation.hashCode ^
      yFilterLength.hashCode ^
      iFilterLength.hashCode ^
      qFilterLength.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NtscBisqwitOptions &&
          runtimeType == other.runtimeType &&
          brightness == other.brightness &&
          contrast == other.contrast &&
          hue == other.hue &&
          saturation == other.saturation &&
          yFilterLength == other.yFilterLength &&
          iFilterLength == other.iFilterLength &&
          qFilterLength == other.qFilterLength;
}

class NtscOptions {
  final double hue;
  final double saturation;
  final double contrast;
  final double brightness;
  final double sharpness;
  final double gamma;
  final double resolution;
  final double artifacts;
  final double fringing;
  final double bleed;
  final bool mergeFields;

  const NtscOptions({
    required this.hue,
    required this.saturation,
    required this.contrast,
    required this.brightness,
    required this.sharpness,
    required this.gamma,
    required this.resolution,
    required this.artifacts,
    required this.fringing,
    required this.bleed,
    required this.mergeFields,
  });

  static Future<NtscOptions> default_() =>
      RustLib.instance.api.crateApiVideoNtscOptionsDefault();

  @override
  int get hashCode =>
      hue.hashCode ^
      saturation.hashCode ^
      contrast.hashCode ^
      brightness.hashCode ^
      sharpness.hashCode ^
      gamma.hashCode ^
      resolution.hashCode ^
      artifacts.hashCode ^
      fringing.hashCode ^
      bleed.hashCode ^
      mergeFields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NtscOptions &&
          runtimeType == other.runtimeType &&
          hue == other.hue &&
          saturation == other.saturation &&
          contrast == other.contrast &&
          brightness == other.brightness &&
          sharpness == other.sharpness &&
          gamma == other.gamma &&
          resolution == other.resolution &&
          artifacts == other.artifacts &&
          fringing == other.fringing &&
          bleed == other.bleed &&
          mergeFields == other.mergeFields;
}

class ScanlineOptions {
  /// Scanline intensity in `0.0..=1.0` (0 = off, 1 = strongest).
  final double intensity;

  const ScanlineOptions({required this.intensity});

  static Future<ScanlineOptions> default_() =>
      RustLib.instance.api.crateApiVideoScanlineOptionsDefault();

  @override
  int get hashCode => intensity.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScanlineOptions &&
          runtimeType == other.runtimeType &&
          intensity == other.intensity;
}

class ShaderParameter {
  final String name;
  final String description;
  final double initial;
  final double current;
  final double minimum;
  final double maximum;
  final double step;

  const ShaderParameter({
    required this.name,
    required this.description,
    required this.initial,
    required this.current,
    required this.minimum,
    required this.maximum,
    required this.step,
  });

  @override
  int get hashCode =>
      name.hashCode ^
      description.hashCode ^
      initial.hashCode ^
      current.hashCode ^
      minimum.hashCode ^
      maximum.hashCode ^
      step.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShaderParameter &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          description == other.description &&
          initial == other.initial &&
          current == other.current &&
          minimum == other.minimum &&
          maximum == other.maximum &&
          step == other.step;
}

class ShaderParameters {
  final String path;
  final Map<String, ShaderParameter> parameters;

  const ShaderParameters({required this.path, required this.parameters});

  @override
  int get hashCode => path.hashCode ^ parameters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ShaderParameters &&
          runtimeType == other.runtimeType &&
          path == other.path &&
          parameters == other.parameters;
}

/// Single-select video filter configuration, modeled after Mesen's `VideoFilterType`.
///
/// Notes:
/// - `None` keeps the output at the canonical NES size (256×240).
/// - `PrescaleNx` outputs an integer-scaled frame (N×) in the runtime's packed framebuffer.
/// - `HqNx` outputs an integer-scaled frame (N×) using HQX (hq2x/hq3x/hq4x).
enum VideoFilter {
  none,
  prescale2X,
  prescale3X,
  prescale4X,
  hq2X,
  hq3X,
  hq4X,
  sai2X,
  super2XSai,
  superEagle,
  ntscComposite,
  ntscSVideo,
  ntscRgb,
  ntscMonochrome,
  lcdGrid,
  scanlines,
  xbrz2X,
  xbrz3X,
  xbrz4X,
  xbrz5X,
  xbrz6X,
  ntscBisqwit2X,
  ntscBisqwit4X,
  ntscBisqwit8X,
}

class VideoOutputInfo {
  final int outputWidth;
  final int outputHeight;

  const VideoOutputInfo({
    required this.outputWidth,
    required this.outputHeight,
  });

  @override
  int get hashCode => outputWidth.hashCode ^ outputHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoOutputInfo &&
          runtimeType == other.runtimeType &&
          outputWidth == other.outputWidth &&
          outputHeight == other.outputHeight;
}
