// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `apply_video_filter`, `current_filter`, `is_ntsc_filter`, `ntsc_options`, `output_size`, `scale_factor`, `set_current_filter`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`

Future<VideoOutputInfo> setVideoFilter({required VideoFilter filter}) =>
    RustLib.instance.api.crateApiVideoSetVideoFilter(filter: filter);

Future<void> setNtscOptions({required NtscOptions options}) =>
    RustLib.instance.api.crateApiVideoSetNtscOptions(options: options);

class NtscOptions {
  final double hue;
  final double saturation;
  final double contrast;
  final double brightness;
  final double sharpness;
  final double gamma;
  final double resolution;
  final double artifacts;
  final double fringing;
  final double bleed;
  final bool mergeFields;

  const NtscOptions({
    required this.hue,
    required this.saturation,
    required this.contrast,
    required this.brightness,
    required this.sharpness,
    required this.gamma,
    required this.resolution,
    required this.artifacts,
    required this.fringing,
    required this.bleed,
    required this.mergeFields,
  });

  static Future<NtscOptions> default_() =>
      RustLib.instance.api.crateApiVideoNtscOptionsDefault();

  @override
  int get hashCode =>
      hue.hashCode ^
      saturation.hashCode ^
      contrast.hashCode ^
      brightness.hashCode ^
      sharpness.hashCode ^
      gamma.hashCode ^
      resolution.hashCode ^
      artifacts.hashCode ^
      fringing.hashCode ^
      bleed.hashCode ^
      mergeFields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NtscOptions &&
          runtimeType == other.runtimeType &&
          hue == other.hue &&
          saturation == other.saturation &&
          contrast == other.contrast &&
          brightness == other.brightness &&
          sharpness == other.sharpness &&
          gamma == other.gamma &&
          resolution == other.resolution &&
          artifacts == other.artifacts &&
          fringing == other.fringing &&
          bleed == other.bleed &&
          mergeFields == other.mergeFields;
}

/// Single-select video filter configuration, modeled after Mesen's `VideoFilterType`.
///
/// Notes:
/// - `None` keeps the output at the canonical NES size (256×240).
/// - `PrescaleNx` outputs an integer-scaled frame (N×) in the runtime's packed framebuffer.
/// - `HqNx` outputs an integer-scaled frame (N×) using HQX (hq2x/hq3x/hq4x).
enum VideoFilter {
  none,
  prescale2X,
  prescale3X,
  prescale4X,
  hq2X,
  hq3X,
  hq4X,
  ntscComposite,
  ntscSVideo,
  ntscRgb,
  ntscMonochrome,
}

class VideoOutputInfo {
  final int outputWidth;
  final int outputHeight;

  const VideoOutputInfo({
    required this.outputWidth,
    required this.outputHeight,
  });

  @override
  int get hashCode => outputWidth.hashCode ^ outputHeight.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VideoOutputInfo &&
          runtimeType == other.runtimeType &&
          outputWidth == other.outputWidth &&
          outputHeight == other.outputHeight;
}
