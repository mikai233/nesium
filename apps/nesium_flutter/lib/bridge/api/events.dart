// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Runtime notification stream.
///
/// This registers the sink directly with the runtime.
Stream<RuntimeNotification> runtimeNotifications() =>
    RustLib.instance.api.crateApiEventsRuntimeNotifications();

/// Subscribes to debug state updates (CPU/PPU registers per frame).
///
/// Call this when opening the debug panel. The stream will receive updates
/// every frame until cancelled.
Stream<DebugStateNotification> debugStateStream() =>
    RustLib.instance.api.crateApiEventsDebugStateStream();

/// Unsubscribes from debug state updates.
///
/// Call this when closing the debug panel to stop unnecessary computation.
Future<void> unsubscribeDebugState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeDebugState();

/// Subscribes to tilemap texture updates.
///
/// This enables per-frame rendering of the tilemap to the auxiliary texture.
/// The actual pixel data is written directly to the texture buffer, not sent via stream.
Future<void> subscribeTilemapTexture() =>
    RustLib.instance.api.crateApiEventsSubscribeTilemapTexture();

/// Unsubscribes from tilemap texture updates.
Future<void> unsubscribeTilemapTexture() =>
    RustLib.instance.api.crateApiEventsUnsubscribeTilemapTexture();

/// Subscribes to tilemap state updates.
///
/// This also refreshes the tilemap auxiliary texture, so the UI can use a single subscription.
Stream<TilemapSnapshot> tilemapStateStream() =>
    RustLib.instance.api.crateApiEventsTilemapStateStream();

/// Use the PPU frame start (scanline 0, cycle 0) as the tilemap capture point.
Future<void> setTilemapCaptureFrameStart() =>
    RustLib.instance.api.crateApiEventsSetTilemapCaptureFrameStart();

/// Use the PPU VBlank start (scanline 241, cycle 1) as the tilemap capture point.
Future<void> setTilemapCaptureVblankStart() =>
    RustLib.instance.api.crateApiEventsSetTilemapCaptureVblankStart();

/// Use a specific scanline and dot as the tilemap capture point.
Future<void> setTilemapCaptureScanline({
  required int scanline,
  required int dot,
}) => RustLib.instance.api.crateApiEventsSetTilemapCaptureScanline(
  scanline: scanline,
  dot: dot,
);

/// Sets the render mode for the tilemap auxiliary texture.
///
/// - `0`: Default
/// - `1`: Grayscale
/// - `2`: Attribute view
Future<void> setTilemapDisplayMode({required int mode}) =>
    RustLib.instance.api.crateApiEventsSetTilemapDisplayMode(mode: mode);

/// Subscribes to CHR state updates.
///
/// This refreshes the CHR auxiliary texture, so the UI can use a single subscription.
Stream<ChrSnapshot> chrStateStream() =>
    RustLib.instance.api.crateApiEventsChrStateStream();

/// Unsubscribes from CHR state updates.
Future<void> unsubscribeChrState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeChrState();

/// Sets the palette index for CHR rendering.
///
/// - `0-3`: Background palettes
/// - `4-7`: Sprite palettes
Future<void> setChrPalette({required int paletteIndex}) => RustLib.instance.api
    .crateApiEventsSetChrPalette(paletteIndex: paletteIndex);

/// Sets the display mode for CHR auxiliary texture.
///
/// - `0`: Default (use selected palette)
/// - `1`: Grayscale
Future<void> setChrDisplayMode({required int mode}) =>
    RustLib.instance.api.crateApiEventsSetChrDisplayMode(mode: mode);

/// Sets the CHR preset source for the Tile Viewer.
///
/// - `0`: PPU (current PPU-visible CHR at $0000-$1FFF)
/// - `1`: CHR (cartridge CHR ROM/RAM, first 8 KiB)
/// - `2`: ROM (cartridge PRG ROM, first 8 KiB)
Future<void> setChrSource({required int source}) =>
    RustLib.instance.api.crateApiEventsSetChrSource(source: source);

/// Sets the tile viewer source.
///
/// - `0`: PPU
/// - `1`: CHR ROM
/// - `2`: CHR RAM
/// - `3`: PRG ROM
Future<void> setTileViewerSource({required int source}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerSource(source: source);

Future<void> setTileViewerStartAddress({required int startAddress}) => RustLib
    .instance
    .api
    .crateApiEventsSetTileViewerStartAddress(startAddress: startAddress);

Future<void> setTileViewerSize({required int columns, required int rows}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerSize(
      columns: columns,
      rows: rows,
    );

/// Sets the tile layout.
///
/// - `0`: Normal
/// - `1`: SingleLine8x16
/// - `2`: SingleLine16x16
Future<void> setTileViewerLayout({required int layout}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerLayout(layout: layout);

/// Sets the tile background.
///
/// - `0`: Default
/// - `1`: Transparent
/// - `2`: PaletteColor
/// - `3`: Black
/// - `4`: White
/// - `5`: Magenta
Future<void> setTileViewerBackground({required int background}) => RustLib
    .instance
    .api
    .crateApiEventsSetTileViewerBackground(background: background);

/// Subscribes to Sprite state updates.
///
/// This refreshes the Sprite auxiliary texture, so the UI can use a single subscription.
Stream<SpriteSnapshot> spriteStateStream() =>
    RustLib.instance.api.crateApiEventsSpriteStateStream();

/// Unsubscribes from Sprite state updates.
Future<void> unsubscribeSpriteState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeSpriteState();

/// CHR snapshot for UI inspection (tile preview, palette selection, etc).
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class ChrSnapshot {
  final Uint8List palette;
  final Uint8List rgbaPalette;
  final int selectedPalette;
  final int width;
  final int height;

  /// `0..=3` as per `set_tile_viewer_source`.
  final int source;
  final int sourceSize;
  final int startAddress;
  final int columnCount;
  final int rowCount;

  /// `0..=2` as per `set_tile_viewer_layout`.
  final int layout;

  /// `0..=5` as per `set_tile_viewer_background`.
  final int background;
  final bool useGrayscalePalette;
  final int bgPatternBase;
  final int spritePatternBase;
  final bool largeSprites;

  const ChrSnapshot({
    required this.palette,
    required this.rgbaPalette,
    required this.selectedPalette,
    required this.width,
    required this.height,
    required this.source,
    required this.sourceSize,
    required this.startAddress,
    required this.columnCount,
    required this.rowCount,
    required this.layout,
    required this.background,
    required this.useGrayscalePalette,
    required this.bgPatternBase,
    required this.spritePatternBase,
    required this.largeSprites,
  });

  @override
  int get hashCode =>
      palette.hashCode ^
      rgbaPalette.hashCode ^
      selectedPalette.hashCode ^
      width.hashCode ^
      height.hashCode ^
      source.hashCode ^
      sourceSize.hashCode ^
      startAddress.hashCode ^
      columnCount.hashCode ^
      rowCount.hashCode ^
      layout.hashCode ^
      background.hashCode ^
      useGrayscalePalette.hashCode ^
      bgPatternBase.hashCode ^
      spritePatternBase.hashCode ^
      largeSprites.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChrSnapshot &&
          runtimeType == other.runtimeType &&
          palette == other.palette &&
          rgbaPalette == other.rgbaPalette &&
          selectedPalette == other.selectedPalette &&
          width == other.width &&
          height == other.height &&
          source == other.source &&
          sourceSize == other.sourceSize &&
          startAddress == other.startAddress &&
          columnCount == other.columnCount &&
          rowCount == other.rowCount &&
          layout == other.layout &&
          background == other.background &&
          useGrayscalePalette == other.useGrayscalePalette &&
          bgPatternBase == other.bgPatternBase &&
          spritePatternBase == other.spritePatternBase &&
          largeSprites == other.largeSprites;
}

/// Debug state notification sent per-frame when subscribed.
class DebugStateNotification {
  final int cpuPc;
  final int cpuA;
  final int cpuX;
  final int cpuY;
  final int cpuSp;
  final int cpuStatus;
  final BigInt cpuCycle;
  final int ppuScanline;
  final int ppuCycle;
  final int ppuFrame;
  final int ppuCtrl;
  final int ppuMask;
  final int ppuStatus;

  const DebugStateNotification({
    required this.cpuPc,
    required this.cpuA,
    required this.cpuX,
    required this.cpuY,
    required this.cpuSp,
    required this.cpuStatus,
    required this.cpuCycle,
    required this.ppuScanline,
    required this.ppuCycle,
    required this.ppuFrame,
    required this.ppuCtrl,
    required this.ppuMask,
    required this.ppuStatus,
  });

  @override
  int get hashCode =>
      cpuPc.hashCode ^
      cpuA.hashCode ^
      cpuX.hashCode ^
      cpuY.hashCode ^
      cpuSp.hashCode ^
      cpuStatus.hashCode ^
      cpuCycle.hashCode ^
      ppuScanline.hashCode ^
      ppuCycle.hashCode ^
      ppuFrame.hashCode ^
      ppuCtrl.hashCode ^
      ppuMask.hashCode ^
      ppuStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DebugStateNotification &&
          runtimeType == other.runtimeType &&
          cpuPc == other.cpuPc &&
          cpuA == other.cpuA &&
          cpuX == other.cpuX &&
          cpuY == other.cpuY &&
          cpuSp == other.cpuSp &&
          cpuStatus == other.cpuStatus &&
          cpuCycle == other.cpuCycle &&
          ppuScanline == other.ppuScanline &&
          ppuCycle == other.ppuCycle &&
          ppuFrame == other.ppuFrame &&
          ppuCtrl == other.ppuCtrl &&
          ppuMask == other.ppuMask &&
          ppuStatus == other.ppuStatus;
}

class RuntimeNotification {
  final RuntimeNotificationKind kind;
  final String? error;

  const RuntimeNotification({required this.kind, this.error});

  @override
  int get hashCode => kind.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RuntimeNotification &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          error == other.error;
}

enum RuntimeNotificationKind { audioInitFailed }

/// Information about a single OAM sprite.
class SpriteInfo {
  final int index;
  final int x;
  final int y;
  final int tileIndex;
  final int palette;
  final bool flipH;
  final bool flipV;
  final bool behindBg;
  final bool visible;

  const SpriteInfo({
    required this.index,
    required this.x,
    required this.y,
    required this.tileIndex,
    required this.palette,
    required this.flipH,
    required this.flipV,
    required this.behindBg,
    required this.visible,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      x.hashCode ^
      y.hashCode ^
      tileIndex.hashCode ^
      palette.hashCode ^
      flipH.hashCode ^
      flipV.hashCode ^
      behindBg.hashCode ^
      visible.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpriteInfo &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          x == other.x &&
          y == other.y &&
          tileIndex == other.tileIndex &&
          palette == other.palette &&
          flipH == other.flipH &&
          flipV == other.flipV &&
          behindBg == other.behindBg &&
          visible == other.visible;
}

/// Sprite snapshot for UI inspection.
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class SpriteSnapshot {
  final List<SpriteInfo> sprites;
  final int thumbnailWidth;
  final int thumbnailHeight;
  final bool largeSprites;
  final int patternBase;
  final Uint8List rgbaPalette;

  const SpriteSnapshot({
    required this.sprites,
    required this.thumbnailWidth,
    required this.thumbnailHeight,
    required this.largeSprites,
    required this.patternBase,
    required this.rgbaPalette,
  });

  @override
  int get hashCode =>
      sprites.hashCode ^
      thumbnailWidth.hashCode ^
      thumbnailHeight.hashCode ^
      largeSprites.hashCode ^
      patternBase.hashCode ^
      rgbaPalette.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpriteSnapshot &&
          runtimeType == other.runtimeType &&
          sprites == other.sprites &&
          thumbnailWidth == other.thumbnailWidth &&
          thumbnailHeight == other.thumbnailHeight &&
          largeSprites == other.largeSprites &&
          patternBase == other.patternBase &&
          rgbaPalette == other.rgbaPalette;
}

enum TilemapMirroring {
  horizontal,
  vertical,
  fourScreen,
  singleScreenLower,
  singleScreenUpper,
  mapperControlled,
}

/// Tilemap snapshot for UI inspection (hover/selection, tile preview, etc).
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class TilemapSnapshot {
  final Uint8List ciram;
  final Uint8List palette;
  final Uint8List chr;
  final TilemapMirroring mirroring;
  final int bgPatternBase;
  final Uint8List rgbaPalette;
  final int vramAddr;
  final int tempAddr;
  final int fineX;

  const TilemapSnapshot({
    required this.ciram,
    required this.palette,
    required this.chr,
    required this.mirroring,
    required this.bgPatternBase,
    required this.rgbaPalette,
    required this.vramAddr,
    required this.tempAddr,
    required this.fineX,
  });

  @override
  int get hashCode =>
      ciram.hashCode ^
      palette.hashCode ^
      chr.hashCode ^
      mirroring.hashCode ^
      bgPatternBase.hashCode ^
      rgbaPalette.hashCode ^
      vramAddr.hashCode ^
      tempAddr.hashCode ^
      fineX.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TilemapSnapshot &&
          runtimeType == other.runtimeType &&
          ciram == other.ciram &&
          palette == other.palette &&
          chr == other.chr &&
          mirroring == other.mirroring &&
          bgPatternBase == other.bgPatternBase &&
          rgbaPalette == other.rgbaPalette &&
          vramAddr == other.vramAddr &&
          tempAddr == other.tempAddr &&
          fineX == other.fineX;
}
