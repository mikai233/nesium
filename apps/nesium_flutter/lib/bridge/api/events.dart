// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Runtime notification stream.
///
/// This registers the sink directly with the runtime.
Stream<RuntimeNotification> runtimeNotifications() =>
    RustLib.instance.api.crateApiEventsRuntimeNotifications();

/// Subscribes to debug state updates (CPU/PPU registers per frame).
///
/// Call this when opening the debug panel. The stream will receive updates
/// every frame until cancelled.
Stream<DebugStateNotification> debugStateStream() =>
    RustLib.instance.api.crateApiEventsDebugStateStream();

/// Unsubscribes from debug state updates.
///
/// Call this when closing the debug panel to stop unnecessary computation.
Future<void> unsubscribeDebugState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeDebugState();

/// Subscribes to tilemap texture updates.
///
/// This enables per-frame rendering of the tilemap to the auxiliary texture.
/// The actual pixel data is written directly to the texture buffer, not sent via stream.
Future<void> subscribeTilemapTexture() =>
    RustLib.instance.api.crateApiEventsSubscribeTilemapTexture();

/// Unsubscribes from tilemap texture updates.
Future<void> unsubscribeTilemapTexture() =>
    RustLib.instance.api.crateApiEventsUnsubscribeTilemapTexture();

/// Subscribes to tilemap state updates.
///
/// This also refreshes the tilemap auxiliary texture, so the UI can use a single subscription.
Stream<TilemapSnapshot> tilemapStateStream() =>
    RustLib.instance.api.crateApiEventsTilemapStateStream();

/// Use the PPU frame start (scanline 0, cycle 0) as the tilemap capture point.
Future<void> setTilemapCaptureFrameStart() =>
    RustLib.instance.api.crateApiEventsSetTilemapCaptureFrameStart();

/// Use the PPU VBlank start (scanline 241, cycle 1) as the tilemap capture point.
Future<void> setTilemapCaptureVblankStart() =>
    RustLib.instance.api.crateApiEventsSetTilemapCaptureVblankStart();

/// Use a specific scanline and dot as the tilemap capture point.
Future<void> setTilemapCaptureScanline({
  required int scanline,
  required int dot,
}) => RustLib.instance.api.crateApiEventsSetTilemapCaptureScanline(
  scanline: scanline,
  dot: dot,
);

/// Sets the render mode for the tilemap auxiliary texture.
///
/// - `0`: Default
/// - `1`: Grayscale
/// - `2`: Attribute view
Future<void> setTilemapDisplayMode({required int mode}) =>
    RustLib.instance.api.crateApiEventsSetTilemapDisplayMode(mode: mode);

/// Subscribes to CHR state updates.
///
/// This refreshes the CHR auxiliary texture, so the UI can use a single subscription.
Stream<ChrSnapshot> chrStateStream() =>
    RustLib.instance.api.crateApiEventsChrStateStream();

/// Unsubscribes from CHR state updates.
Future<void> unsubscribeChrState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeChrState();

/// Sets the palette index for CHR rendering.
///
/// - `0-3`: Background palettes
/// - `4-7`: Sprite palettes
Future<void> setChrPalette({required int paletteIndex}) => RustLib.instance.api
    .crateApiEventsSetChrPalette(paletteIndex: paletteIndex);

/// CHR snapshot for UI inspection (tile preview, palette selection, etc).
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class ChrSnapshot {
  final Uint8List chr;
  final Uint8List palette;
  final Uint8List rgbaPalette;
  final int selectedPalette;

  const ChrSnapshot({
    required this.chr,
    required this.palette,
    required this.rgbaPalette,
    required this.selectedPalette,
  });

  @override
  int get hashCode =>
      chr.hashCode ^
      palette.hashCode ^
      rgbaPalette.hashCode ^
      selectedPalette.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChrSnapshot &&
          runtimeType == other.runtimeType &&
          chr == other.chr &&
          palette == other.palette &&
          rgbaPalette == other.rgbaPalette &&
          selectedPalette == other.selectedPalette;
}

/// Debug state notification sent per-frame when subscribed.
class DebugStateNotification {
  final int cpuPc;
  final int cpuA;
  final int cpuX;
  final int cpuY;
  final int cpuSp;
  final int cpuStatus;
  final BigInt cpuCycle;
  final int ppuScanline;
  final int ppuCycle;
  final int ppuFrame;
  final int ppuCtrl;
  final int ppuMask;
  final int ppuStatus;

  const DebugStateNotification({
    required this.cpuPc,
    required this.cpuA,
    required this.cpuX,
    required this.cpuY,
    required this.cpuSp,
    required this.cpuStatus,
    required this.cpuCycle,
    required this.ppuScanline,
    required this.ppuCycle,
    required this.ppuFrame,
    required this.ppuCtrl,
    required this.ppuMask,
    required this.ppuStatus,
  });

  @override
  int get hashCode =>
      cpuPc.hashCode ^
      cpuA.hashCode ^
      cpuX.hashCode ^
      cpuY.hashCode ^
      cpuSp.hashCode ^
      cpuStatus.hashCode ^
      cpuCycle.hashCode ^
      ppuScanline.hashCode ^
      ppuCycle.hashCode ^
      ppuFrame.hashCode ^
      ppuCtrl.hashCode ^
      ppuMask.hashCode ^
      ppuStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DebugStateNotification &&
          runtimeType == other.runtimeType &&
          cpuPc == other.cpuPc &&
          cpuA == other.cpuA &&
          cpuX == other.cpuX &&
          cpuY == other.cpuY &&
          cpuSp == other.cpuSp &&
          cpuStatus == other.cpuStatus &&
          cpuCycle == other.cpuCycle &&
          ppuScanline == other.ppuScanline &&
          ppuCycle == other.ppuCycle &&
          ppuFrame == other.ppuFrame &&
          ppuCtrl == other.ppuCtrl &&
          ppuMask == other.ppuMask &&
          ppuStatus == other.ppuStatus;
}

class RuntimeNotification {
  final RuntimeNotificationKind kind;
  final String? error;

  const RuntimeNotification({required this.kind, this.error});

  @override
  int get hashCode => kind.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RuntimeNotification &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          error == other.error;
}

enum RuntimeNotificationKind { audioInitFailed }

enum TilemapMirroring {
  horizontal,
  vertical,
  fourScreen,
  singleScreenLower,
  singleScreenUpper,
  mapperControlled,
}

/// Tilemap snapshot for UI inspection (hover/selection, tile preview, etc).
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class TilemapSnapshot {
  final Uint8List ciram;
  final Uint8List palette;
  final Uint8List chr;
  final TilemapMirroring mirroring;
  final int bgPatternBase;
  final Uint8List rgbaPalette;
  final int vramAddr;
  final int tempAddr;
  final int fineX;

  const TilemapSnapshot({
    required this.ciram,
    required this.palette,
    required this.chr,
    required this.mirroring,
    required this.bgPatternBase,
    required this.rgbaPalette,
    required this.vramAddr,
    required this.tempAddr,
    required this.fineX,
  });

  @override
  int get hashCode =>
      ciram.hashCode ^
      palette.hashCode ^
      chr.hashCode ^
      mirroring.hashCode ^
      bgPatternBase.hashCode ^
      rgbaPalette.hashCode ^
      vramAddr.hashCode ^
      tempAddr.hashCode ^
      fineX.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TilemapSnapshot &&
          runtimeType == other.runtimeType &&
          ciram == other.ciram &&
          palette == other.palette &&
          chr == other.chr &&
          mirroring == other.mirroring &&
          bgPatternBase == other.bgPatternBase &&
          rgbaPalette == other.rgbaPalette &&
          vramAddr == other.vramAddr &&
          tempAddr == other.tempAddr &&
          fineX == other.fineX;
}
