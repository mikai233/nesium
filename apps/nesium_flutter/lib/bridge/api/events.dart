// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `emulation_status_sink`, `notify_emulation_status`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// Returns all auxiliary texture IDs defined on the Rust side.
///
/// Flutter should treat these as the single source of truth and avoid hard-coding IDs.
Future<AuxTextureIds> auxTextureIds() =>
    RustLib.instance.api.crateApiEventsAuxTextureIds();

/// Runtime notification stream.
///
/// This registers the sink directly with the runtime.
Stream<RuntimeNotification> runtimeNotifications() =>
    RustLib.instance.api.crateApiEventsRuntimeNotifications();

/// Emulation status stream.
///
/// Used to notify Flutter UI about pause/rewind/fast-forward changes that are triggered on the Rust
/// side (e.g. desktop gamepad polling thread).
Stream<EmulationStatusNotification> emulationStatusStream() =>
    RustLib.instance.api.crateApiEventsEmulationStatusStream();

/// Subscribes to debug state updates (CPU/PPU registers per frame).
///
/// Call this when opening the debug panel. The stream will receive updates
/// every frame until cancelled.
Stream<DebugStateNotification> debugStateStream() =>
    RustLib.instance.api.crateApiEventsDebugStateStream();

/// Unsubscribes from debug state updates.
///
/// Call this when closing the debug panel to stop unnecessary computation.
Future<void> unsubscribeDebugState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeDebugState();

/// Subscribes to tilemap texture updates.
///
/// This enables per-frame rendering of the tilemap to the auxiliary texture.
/// The actual pixel data is written directly to the texture buffer, not sent via stream.
Future<void> subscribeTilemapTexture() =>
    RustLib.instance.api.crateApiEventsSubscribeTilemapTexture();

/// Unsubscribes from tilemap texture updates.
Future<void> unsubscribeTilemapTexture() =>
    RustLib.instance.api.crateApiEventsUnsubscribeTilemapTexture();

/// Subscribes to tilemap state updates.
///
/// This also refreshes the tilemap auxiliary texture, so the UI can use a single subscription.
Stream<TilemapSnapshot> tilemapStateStream() =>
    RustLib.instance.api.crateApiEventsTilemapStateStream();

/// Use the PPU frame start (scanline 0, cycle 0) as the tilemap capture point.
Future<void> setTilemapCaptureFrameStart() =>
    RustLib.instance.api.crateApiEventsSetTilemapCaptureFrameStart();

/// Use the PPU VBlank start (scanline 241, cycle 1) as the tilemap capture point.
Future<void> setTilemapCaptureVblankStart() =>
    RustLib.instance.api.crateApiEventsSetTilemapCaptureVblankStart();

/// Use a specific scanline and dot as the tilemap capture point.
Future<void> setTilemapCaptureScanline({
  required int scanline,
  required int dot,
}) => RustLib.instance.api.crateApiEventsSetTilemapCaptureScanline(
  scanline: scanline,
  dot: dot,
);

/// Use the PPU frame start (scanline 0, cycle 0) as the Tile Viewer capture point.
Future<void> setTileViewerCaptureFrameStart() =>
    RustLib.instance.api.crateApiEventsSetTileViewerCaptureFrameStart();

/// Use the PPU VBlank start (scanline 241, cycle 1) as the Tile Viewer capture point.
Future<void> setTileViewerCaptureVblankStart() =>
    RustLib.instance.api.crateApiEventsSetTileViewerCaptureVblankStart();

/// Use a specific scanline and dot as the Tile Viewer capture point.
Future<void> setTileViewerCaptureScanline({
  required int scanline,
  required int dot,
}) => RustLib.instance.api.crateApiEventsSetTileViewerCaptureScanline(
  scanline: scanline,
  dot: dot,
);

/// Sets the render mode for the tilemap auxiliary texture.
///
/// - `0`: Default
/// - `1`: Grayscale
/// - `2`: Attribute view
Future<void> setTilemapDisplayMode({required int mode}) =>
    RustLib.instance.api.crateApiEventsSetTilemapDisplayMode(mode: mode);

/// Subscribes to Tile state updates.
///
/// This refreshes the Tile auxiliary texture, so the UI can use a single subscription.
Stream<TileSnapshot> tileStateStream() =>
    RustLib.instance.api.crateApiEventsTileStateStream();

/// Unsubscribes from Tile state updates.
Future<void> unsubscribeTileState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeTileState();

/// Sets the palette index for Tile Viewer rendering.
///
/// - `0-3`: Background palettes
/// - `4-7`: Sprite palettes
Future<void> setTileViewerPalette({required int paletteIndex}) => RustLib
    .instance
    .api
    .crateApiEventsSetTileViewerPalette(paletteIndex: paletteIndex);

/// Sets the display mode for Tile Viewer auxiliary texture.
///
/// - `0`: Default (use selected palette)
/// - `1`: Grayscale
Future<void> setTileViewerDisplayMode({required int mode}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerDisplayMode(mode: mode);

/// Sets the tile viewer source.
///
/// - `0`: PPU
/// - `1`: CHR ROM
/// - `2`: CHR RAM
/// - `3`: PRG ROM
Future<void> setTileViewerSource({required int source}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerSource(source: source);

Future<void> setTileViewerStartAddress({required int startAddress}) => RustLib
    .instance
    .api
    .crateApiEventsSetTileViewerStartAddress(startAddress: startAddress);

Future<void> setTileViewerSize({required int columns, required int rows}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerSize(
      columns: columns,
      rows: rows,
    );

/// Sets the tile layout.
///
/// - `0`: Normal
/// - `1`: SingleLine8x16
/// - `2`: SingleLine16x16
Future<void> setTileViewerLayout({required int layout}) =>
    RustLib.instance.api.crateApiEventsSetTileViewerLayout(layout: layout);

/// Sets the tile background.
///
/// - `0`: Default
/// - `1`: Transparent
/// - `2`: PaletteColor
/// - `3`: Black
/// - `4`: White
/// - `5`: Magenta
Future<void> setTileViewerBackground({required int background}) => RustLib
    .instance
    .api
    .crateApiEventsSetTileViewerBackground(background: background);

/// Subscribes to Sprite state updates.
///
/// This refreshes the Sprite auxiliary texture, so the UI can use a single subscription.
Stream<SpriteSnapshot> spriteStateStream() =>
    RustLib.instance.api.crateApiEventsSpriteStateStream();

/// Use the PPU frame start (scanline 0, cycle 0) as the sprite capture point.
Future<void> setSpriteCaptureFrameStart() =>
    RustLib.instance.api.crateApiEventsSetSpriteCaptureFrameStart();

/// Use the PPU VBlank start (scanline 241, cycle 1) as the sprite capture point.
Future<void> setSpriteCaptureVblankStart() =>
    RustLib.instance.api.crateApiEventsSetSpriteCaptureVblankStart();

/// Use a specific scanline and dot as the sprite capture point.
Future<void> setSpriteCaptureScanline({
  required int scanline,
  required int dot,
}) => RustLib.instance.api.crateApiEventsSetSpriteCaptureScanline(
  scanline: scanline,
  dot: dot,
);

/// Unsubscribes from Sprite state updates.
Future<void> unsubscribeSpriteState() =>
    RustLib.instance.api.crateApiEventsUnsubscribeSpriteState();

/// Subscribes to Palette state updates.
///
/// This streams the current palette to Flutter every frame.
Stream<PaletteSnapshot> paletteStateStream() =>
    RustLib.instance.api.crateApiEventsPaletteStateStream();

/// Unsubscribes from Palette state updates.
Future<void> unsubscribePaletteState() =>
    RustLib.instance.api.crateApiEventsUnsubscribePaletteState();

/// Use the PPU frame start (scanline 0, cycle 0) as the palette capture point.
Future<void> setPaletteCaptureFrameStart() =>
    RustLib.instance.api.crateApiEventsSetPaletteCaptureFrameStart();

/// Use the PPU VBlank start (scanline 241, cycle 1) as the palette capture point.
Future<void> setPaletteCaptureVblankStart() =>
    RustLib.instance.api.crateApiEventsSetPaletteCaptureVblankStart();

/// Use a specific scanline and dot as the palette capture point.
Future<void> setPaletteCaptureScanline({
  required int scanline,
  required int dot,
}) => RustLib.instance.api.crateApiEventsSetPaletteCaptureScanline(
  scanline: scanline,
  dot: dot,
);

class AuxTextureIds {
  final int tilemap;
  final int tile;
  final int sprite;
  final int spriteScreen;

  const AuxTextureIds({
    required this.tilemap,
    required this.tile,
    required this.sprite,
    required this.spriteScreen,
  });

  @override
  int get hashCode =>
      tilemap.hashCode ^
      tile.hashCode ^
      sprite.hashCode ^
      spriteScreen.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuxTextureIds &&
          runtimeType == other.runtimeType &&
          tilemap == other.tilemap &&
          tile == other.tile &&
          sprite == other.sprite &&
          spriteScreen == other.spriteScreen;
}

/// Debug state notification sent per-frame when subscribed.
class DebugStateNotification {
  final int cpuPc;
  final int cpuA;
  final int cpuX;
  final int cpuY;
  final int cpuSp;
  final int cpuStatus;
  final BigInt cpuCycle;
  final int ppuScanline;
  final int ppuCycle;
  final int ppuFrame;
  final int ppuCtrl;
  final int ppuMask;
  final int ppuStatus;

  const DebugStateNotification({
    required this.cpuPc,
    required this.cpuA,
    required this.cpuX,
    required this.cpuY,
    required this.cpuSp,
    required this.cpuStatus,
    required this.cpuCycle,
    required this.ppuScanline,
    required this.ppuCycle,
    required this.ppuFrame,
    required this.ppuCtrl,
    required this.ppuMask,
    required this.ppuStatus,
  });

  @override
  int get hashCode =>
      cpuPc.hashCode ^
      cpuA.hashCode ^
      cpuX.hashCode ^
      cpuY.hashCode ^
      cpuSp.hashCode ^
      cpuStatus.hashCode ^
      cpuCycle.hashCode ^
      ppuScanline.hashCode ^
      ppuCycle.hashCode ^
      ppuFrame.hashCode ^
      ppuCtrl.hashCode ^
      ppuMask.hashCode ^
      ppuStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DebugStateNotification &&
          runtimeType == other.runtimeType &&
          cpuPc == other.cpuPc &&
          cpuA == other.cpuA &&
          cpuX == other.cpuX &&
          cpuY == other.cpuY &&
          cpuSp == other.cpuSp &&
          cpuStatus == other.cpuStatus &&
          cpuCycle == other.cpuCycle &&
          ppuScanline == other.ppuScanline &&
          ppuCycle == other.ppuCycle &&
          ppuFrame == other.ppuFrame &&
          ppuCtrl == other.ppuCtrl &&
          ppuMask == other.ppuMask &&
          ppuStatus == other.ppuStatus;
}

class EmulationStatusNotification {
  final bool paused;
  final bool rewinding;
  final bool fastForwarding;

  const EmulationStatusNotification({
    required this.paused,
    required this.rewinding,
    required this.fastForwarding,
  });

  @override
  int get hashCode =>
      paused.hashCode ^ rewinding.hashCode ^ fastForwarding.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EmulationStatusNotification &&
          runtimeType == other.runtimeType &&
          paused == other.paused &&
          rewinding == other.rewinding &&
          fastForwarding == other.fastForwarding;
}

/// Palette snapshot for UI inspection.
///
/// Contains the 32-byte palette RAM and the 64-entry BGRA palette for rendering.
class PaletteSnapshot {
  /// 32-byte palette RAM (NES internal palette indices $00-$1F).
  final Uint8List palette;

  /// 64-entry BGRA palette flattened (256 bytes = 64 colors Ã— 4 bytes per color).
  /// Format: [B0, G0, R0, A0, B1, G1, R1, A1, ...] for each color index 0-63.
  final Uint8List bgraPalette;

  const PaletteSnapshot({required this.palette, required this.bgraPalette});

  @override
  int get hashCode => palette.hashCode ^ bgraPalette.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PaletteSnapshot &&
          runtimeType == other.runtimeType &&
          palette == other.palette &&
          bgraPalette == other.bgraPalette;
}

class RuntimeNotification {
  final RuntimeNotificationKind kind;
  final String? error;

  const RuntimeNotification({required this.kind, this.error});

  @override
  int get hashCode => kind.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RuntimeNotification &&
          runtimeType == other.runtimeType &&
          kind == other.kind &&
          error == other.error;
}

enum RuntimeNotificationKind { audioInitFailed }

/// Information about a single OAM sprite.
class SpriteInfo {
  final int index;
  final int x;
  final int y;
  final int tileIndex;
  final int palette;
  final bool flipH;
  final bool flipV;
  final bool behindBg;
  final bool visible;

  const SpriteInfo({
    required this.index,
    required this.x,
    required this.y,
    required this.tileIndex,
    required this.palette,
    required this.flipH,
    required this.flipV,
    required this.behindBg,
    required this.visible,
  });

  @override
  int get hashCode =>
      index.hashCode ^
      x.hashCode ^
      y.hashCode ^
      tileIndex.hashCode ^
      palette.hashCode ^
      flipH.hashCode ^
      flipV.hashCode ^
      behindBg.hashCode ^
      visible.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpriteInfo &&
          runtimeType == other.runtimeType &&
          index == other.index &&
          x == other.x &&
          y == other.y &&
          tileIndex == other.tileIndex &&
          palette == other.palette &&
          flipH == other.flipH &&
          flipV == other.flipV &&
          behindBg == other.behindBg &&
          visible == other.visible;
}

/// Sprite snapshot for UI inspection.
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class SpriteSnapshot {
  final List<SpriteInfo> sprites;
  final int thumbnailWidth;
  final int thumbnailHeight;
  final bool largeSprites;
  final int patternBase;
  final Uint8List rgbaPalette;

  const SpriteSnapshot({
    required this.sprites,
    required this.thumbnailWidth,
    required this.thumbnailHeight,
    required this.largeSprites,
    required this.patternBase,
    required this.rgbaPalette,
  });

  @override
  int get hashCode =>
      sprites.hashCode ^
      thumbnailWidth.hashCode ^
      thumbnailHeight.hashCode ^
      largeSprites.hashCode ^
      patternBase.hashCode ^
      rgbaPalette.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpriteSnapshot &&
          runtimeType == other.runtimeType &&
          sprites == other.sprites &&
          thumbnailWidth == other.thumbnailWidth &&
          thumbnailHeight == other.thumbnailHeight &&
          largeSprites == other.largeSprites &&
          patternBase == other.patternBase &&
          rgbaPalette == other.rgbaPalette;
}

/// Tile snapshot for UI inspection (tile preview, palette selection, etc).
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class TileSnapshot {
  final Uint8List palette;
  final Uint8List rgbaPalette;
  final int selectedPalette;
  final int width;
  final int height;

  /// `0..=3` as per `set_tile_viewer_source`.
  final int source;
  final int sourceSize;
  final int startAddress;
  final int columnCount;
  final int rowCount;

  /// `0..=2` as per `set_tile_viewer_layout`.
  final int layout;

  /// `0..=5` as per `set_tile_viewer_background`.
  final int background;
  final bool useGrayscalePalette;
  final int bgPatternBase;
  final int spritePatternBase;
  final bool largeSprites;

  const TileSnapshot({
    required this.palette,
    required this.rgbaPalette,
    required this.selectedPalette,
    required this.width,
    required this.height,
    required this.source,
    required this.sourceSize,
    required this.startAddress,
    required this.columnCount,
    required this.rowCount,
    required this.layout,
    required this.background,
    required this.useGrayscalePalette,
    required this.bgPatternBase,
    required this.spritePatternBase,
    required this.largeSprites,
  });

  @override
  int get hashCode =>
      palette.hashCode ^
      rgbaPalette.hashCode ^
      selectedPalette.hashCode ^
      width.hashCode ^
      height.hashCode ^
      source.hashCode ^
      sourceSize.hashCode ^
      startAddress.hashCode ^
      columnCount.hashCode ^
      rowCount.hashCode ^
      layout.hashCode ^
      background.hashCode ^
      useGrayscalePalette.hashCode ^
      bgPatternBase.hashCode ^
      spritePatternBase.hashCode ^
      largeSprites.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TileSnapshot &&
          runtimeType == other.runtimeType &&
          palette == other.palette &&
          rgbaPalette == other.rgbaPalette &&
          selectedPalette == other.selectedPalette &&
          width == other.width &&
          height == other.height &&
          source == other.source &&
          sourceSize == other.sourceSize &&
          startAddress == other.startAddress &&
          columnCount == other.columnCount &&
          rowCount == other.rowCount &&
          layout == other.layout &&
          background == other.background &&
          useGrayscalePalette == other.useGrayscalePalette &&
          bgPatternBase == other.bgPatternBase &&
          spritePatternBase == other.spritePatternBase &&
          largeSprites == other.largeSprites;
}

enum TilemapMirroring {
  horizontal,
  vertical,
  fourScreen,
  singleScreenLower,
  singleScreenUpper,
  mapperControlled,
}

/// Tilemap snapshot for UI inspection (hover/selection, tile preview, etc).
///
/// Note: `rgba_palette` is ALWAYS RGBA regardless of platform, so Flutter can render it easily.
class TilemapSnapshot {
  final Uint8List ciram;
  final Uint8List palette;
  final Uint8List chr;
  final TilemapMirroring mirroring;
  final int bgPatternBase;
  final Uint8List rgbaPalette;
  final int vramAddr;
  final int tempAddr;
  final int fineX;

  const TilemapSnapshot({
    required this.ciram,
    required this.palette,
    required this.chr,
    required this.mirroring,
    required this.bgPatternBase,
    required this.rgbaPalette,
    required this.vramAddr,
    required this.tempAddr,
    required this.fineX,
  });

  @override
  int get hashCode =>
      ciram.hashCode ^
      palette.hashCode ^
      chr.hashCode ^
      mirroring.hashCode ^
      bgPatternBase.hashCode ^
      rgbaPalette.hashCode ^
      vramAddr.hashCode ^
      tempAddr.hashCode ^
      fineX.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TilemapSnapshot &&
          runtimeType == other.runtimeType &&
          ciram == other.ciram &&
          palette == other.palette &&
          chr == other.chr &&
          mirroring == other.mirroring &&
          bgPatternBase == other.bgPatternBase &&
          rgbaPalette == other.rgbaPalette &&
          vramAddr == other.vramAddr &&
          tempAddr == other.tempAddr &&
          fineX == other.fineX;
}
