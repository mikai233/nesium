// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// Initializes the gamepad subsystem and starts the background polling thread.
///
/// Call this once at app startup. Returns an error if gilrs fails to initialize.
Future<void> initGamepad() => RustLib.instance.api.crateApiGamepadInitGamepad();

/// Polls all connected gamepads and returns the current input state.
///
/// Returns NES button masks, turbo button masks, and extended actions.
/// Call this once per frame.
Future<GamepadPollResultFfi> pollGamepads() =>
    RustLib.instance.api.crateApiGamepadPollGamepads();

/// Returns information about all connected gamepads.
Future<List<GamepadInfoFfi>> listGamepads() =>
    RustLib.instance.api.crateApiGamepadListGamepads();

/// Triggers vibration on the gamepad assigned to the given port.
///
/// - `port`: NES port (0 or 1)
/// - `strength`: Vibration strength (0.0 to 1.0)
/// - `duration_ms`: How long to vibrate in milliseconds
Future<void> rumbleGamepad({
  required int port,
  required double strength,
  required int durationMs,
}) => RustLib.instance.api.crateApiGamepadRumbleGamepad(
  port: port,
  strength: strength,
  durationMs: durationMs,
);

/// Manually binds a gamepad to a NES port.
///
/// - `id`: The gamepad ID (from GamepadInfoFfi).
/// - `port`: 0 for Player 1, 1 for Player 2, or null to unbind.
Future<void> bindGamepad({required BigInt id, int? port}) =>
    RustLib.instance.api.crateApiGamepadBindGamepad(id: id, port: port);

/// Shuts down the gamepad subsystem.
Future<void> shutdownGamepad() =>
    RustLib.instance.api.crateApiGamepadShutdownGamepad();

/// Returns a list of buttons currently pressed on the given gamepad.
Future<List<GamepadButtonFfi>> getGamepadPressedButtons({required BigInt id}) =>
    RustLib.instance.api.crateApiGamepadGetGamepadPressedButtons(id: id);

/// Sets a custom button mapping for the given port.
Future<void> setGamepadMapping({
  required int port,
  required GamepadMappingFfi mapping,
}) => RustLib.instance.api.crateApiGamepadSetGamepadMapping(
  port: port,
  mapping: mapping,
);

/// Returns the current button mapping for a NES port.
Future<GamepadMappingFfi> getGamepadMapping({required int port}) =>
    RustLib.instance.api.crateApiGamepadGetGamepadMapping(port: port);

/// FFI-safe version of GamepadActions.
class GamepadActionsFfi {
  final bool rewind;
  final bool fastForward;
  final bool saveState;
  final bool loadState;
  final bool pause;

  const GamepadActionsFfi({
    required this.rewind,
    required this.fastForward,
    required this.saveState,
    required this.loadState,
    required this.pause,
  });

  static Future<GamepadActionsFfi> default_() =>
      RustLib.instance.api.crateApiGamepadGamepadActionsFfiDefault();

  @override
  int get hashCode =>
      rewind.hashCode ^
      fastForward.hashCode ^
      saveState.hashCode ^
      loadState.hashCode ^
      pause.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GamepadActionsFfi &&
          runtimeType == other.runtimeType &&
          rewind == other.rewind &&
          fastForward == other.fastForward &&
          saveState == other.saveState &&
          loadState == other.loadState &&
          pause == other.pause;
}

/// FFI-safe version of gilrs::Button.
enum GamepadButtonFfi {
  south,
  east,
  north,
  west,
  c,
  z,
  leftTrigger,
  leftTrigger2,
  rightTrigger,
  rightTrigger2,
  select,
  start,
  mode,
  leftThumb,
  rightThumb,
  dPadUp,
  dPadDown,
  dPadLeft,
  dPadRight,
  unknown,
}

/// FFI-safe version of GamepadInfo.
class GamepadInfoFfi {
  final BigInt id;
  final String name;
  final bool connected;
  final int? port;

  const GamepadInfoFfi({
    required this.id,
    required this.name,
    required this.connected,
    this.port,
  });

  @override
  int get hashCode =>
      id.hashCode ^ name.hashCode ^ connected.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GamepadInfoFfi &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          connected == other.connected &&
          port == other.port;
}

/// FFI-safe version of ButtonMapping.
class GamepadMappingFfi {
  final GamepadButtonFfi a;
  final GamepadButtonFfi b;
  final GamepadButtonFfi select;
  final GamepadButtonFfi start;
  final GamepadButtonFfi up;
  final GamepadButtonFfi down;
  final GamepadButtonFfi left;
  final GamepadButtonFfi right;
  final GamepadButtonFfi turboA;
  final GamepadButtonFfi turboB;

  const GamepadMappingFfi({
    required this.a,
    required this.b,
    required this.select,
    required this.start,
    required this.up,
    required this.down,
    required this.left,
    required this.right,
    required this.turboA,
    required this.turboB,
  });

  @override
  int get hashCode =>
      a.hashCode ^
      b.hashCode ^
      select.hashCode ^
      start.hashCode ^
      up.hashCode ^
      down.hashCode ^
      left.hashCode ^
      right.hashCode ^
      turboA.hashCode ^
      turboB.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GamepadMappingFfi &&
          runtimeType == other.runtimeType &&
          a == other.a &&
          b == other.b &&
          select == other.select &&
          start == other.start &&
          up == other.up &&
          down == other.down &&
          left == other.left &&
          right == other.right &&
          turboA == other.turboA &&
          turboB == other.turboB;
}

/// FFI-safe version of GamepadPollResult.
class GamepadPollResultFfi {
  /// NES button masks for ports 0 and 1.
  final Uint8List padMasks;

  /// Turbo button masks for ports 0 and 1.
  final Uint8List turboMasks;

  /// Extended actions.
  final GamepadActionsFfi actions;

  const GamepadPollResultFfi({
    required this.padMasks,
    required this.turboMasks,
    required this.actions,
  });

  static Future<GamepadPollResultFfi> default_() =>
      RustLib.instance.api.crateApiGamepadGamepadPollResultFfiDefault();

  @override
  int get hashCode =>
      padMasks.hashCode ^ turboMasks.hashCode ^ actions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GamepadPollResultFfi &&
          runtimeType == other.runtimeType &&
          padMasks == other.padMasks &&
          turboMasks == other.turboMasks &&
          actions == other.actions;
}
